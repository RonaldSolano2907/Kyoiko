--creación de tablas
CREATE TABLE Estudiante (
    Cedula VARCHAR2(50) PRIMARY KEY,
    Nombre VARCHAR2(50) NOT NULL,
    Apellidos VARCHAR2(50) NOT NULL,
    Telefono VARCHAR2(15),
    FechaNacimiento DATE,
    CorreoElectronico VARCHAR2(100),
    FechaInscripcion DATE,
    Estado VARCHAR2(10) DEFAULT 'activo' CHECK (Estado IN ('activo', 'inactivo'))
);

CREATE TABLE Profesor (
    Cedula VARCHAR2(50) PRIMARY KEY,
    IDDepartamento NUMBER,
    Nombre VARCHAR2(50) NOT NULL,
    Apellidos VARCHAR2(50) NOT NULL,
    Telefono VARCHAR2(15),
    CorreoElectronico VARCHAR2(100),
    FechaInscripcion DATE,
    TituloAcademico VARCHAR2(100),
    CONSTRAINT FK_Profesor_Departamento FOREIGN KEY (IDDepartamento) REFERENCES Departamento(ID)
);

CREATE TABLE Departamento (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaJefeDepartamento VARCHAR2(50),
    Nombre VARCHAR2(100) NOT NULL,
    Descripcion CLOB,
    CONSTRAINT FK_Departamento_Profesor FOREIGN KEY (CedulaJefeDepartamento) REFERENCES Profesor(Cedula)
);

CREATE TABLE Materia (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Nombre VARCHAR2(100) NOT NULL,
    Descripcion CLOB,
    Creditos NUMBER NOT NULL
);

CREATE TABLE Asignacion (
    IDMateria NUMBER,
    CedulaProfesor VARCHAR2(50),
    Semestre NUMBER(4),
    Anio NUMBER(4),
    CONSTRAINT PK_Asignacion PRIMARY KEY (IDMateria, CedulaProfesor, Semestre, Anio),
    CONSTRAINT FK_Asignacion_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID),
    CONSTRAINT FK_Asignacion_Profesor FOREIGN KEY (CedulaProfesor) REFERENCES Profesor(Cedula)
);

CREATE TABLE Matricula (
    CedulaEstudiante VARCHAR2(50),
    IDMateria NUMBER,
    Semestre NUMBER,
    Anio NUMBER,
    FechaMatricula DATE,
    CONSTRAINT PK_Matricula PRIMARY KEY (CedulaEstudiante, IDMateria, Semestre, Anio),
    CONSTRAINT FK_Matricula_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula),
    CONSTRAINT FK_Matricula_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID)
);

CREATE TABLE Prerrequisitos (
    IDMateriaPrincipal NUMBER,
    IDMateriaPrerrequisito NUMBER,
    CONSTRAINT PK_Prerrequisitos PRIMARY KEY (IDMateriaPrincipal, IDMateriaPrerrequisito),
    CONSTRAINT FK_Prerrequisitos_Principal FOREIGN KEY (IDMateriaPrincipal) REFERENCES Materia(ID),
    CONSTRAINT FK_Prerrequisitos_Prerrequisito FOREIGN KEY (IDMateriaPrerrequisito) REFERENCES Materia(ID)
);

CREATE TABLE Congelamientos (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    Motivo CLOB,
    FechaInicio DATE,
    FechaFin DATE,
    CONSTRAINT FK_Congelamientos_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula)
);

CREATE TABLE Direccion (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    Provincia VARCHAR2(50),
    Canton VARCHAR2(50),
    Distrito VARCHAR2(50),
    DireccionExacta CLOB,
    CONSTRAINT FK_Direccion_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula)
);

CREATE TABLE Horarios (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    IDMateria NUMBER,
    Aula VARCHAR2(20),
    HorarioInicio TIMESTAMP,
    HorarioFin TIMESTAMP,
    DiaSemana VARCHAR2(10) CHECK (DiaSemana IN ('Lunes', 'Martes', 'Miercoles', 'Jueves', 'Viernes', 'Sabado', 'Domingo')),
    CONSTRAINT FK_Horarios_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID)
);


--Creación de PROCEDIMIENTOS CRUD en PAQUETES

CREATE OR REPLACE PACKAGE PaqueteEstudiante AS

    PROCEDURE CrearEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE
    );

    PROCEDURE LeerEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Estudiante OUT SYS_REFCURSOR
    );

    PROCEDURE ActualizarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE,
        p_Estado IN Estudiante.Estado%TYPE
    );


    PROCEDURE EliminarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE
    );
END PaqueteEstudiante;

--Implementación del Paquete PaqueteEstudiante

CREATE OR REPLACE PACKAGE BODY PaqueteEstudiante AS

    PROCEDURE CrearEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE
    ) AS
    BEGIN
        INSERT INTO Estudiante (
            Cedula, Nombre, Apellidos, Telefono, FechaNacimiento, CorreoElectronico, FechaInscripcion, Estado
        ) VALUES (
            p_Cedula, p_Nombre, p_Apellidos, p_Telefono, p_FechaNacimiento, p_CorreoElectronico, SYSDATE, 'activo'
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-20001, 'El estudiante con la cédula ' || p_Cedula || ' ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error al crear el estudiante: ' || SQLERRM);
    END CrearEstudiante;

    PROCEDURE LeerEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Estudiante OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Estudiante FOR
        SELECT * FROM Estudiante WHERE Cedula = p_Cedula;
    END LeerEstudiante;

    PROCEDURE ActualizarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE,
        p_Estado IN Estudiante.Estado%TYPE
    ) AS
    BEGIN
        UPDATE Estudiante
        SET Nombre = p_Nombre,
            Apellidos = p_Apellidos,
            Telefono = p_Telefono,
            FechaNacimiento = p_FechaNacimiento,
            CorreoElectronico = p_CorreoElectronico,
            Estado = p_Estado
        WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 'El estudiante con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20004, 'Error al actualizar el estudiante: ' || SQLERRM);
    END ActualizarEstudiante;

    PROCEDURE EliminarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE
    ) AS
    BEGIN
        DELETE FROM Estudiante WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20005, 'El estudiante con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20006, 'Error al eliminar el estudiante: ' || SQLERRM);
    END EliminarEstudiante;

END PaqueteEstudiante;

CREATE OR REPLACE PACKAGE PaqueteProfesor AS
    
    PROCEDURE CrearProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    );

    
    PROCEDURE LeerProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_Profesor OUT SYS_REFCURSOR
    );

   
    PROCEDURE ActualizarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    );

   
    PROCEDURE EliminarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE
    );
END PaqueteProfesor;

CREATE OR REPLACE PACKAGE BODY PaqueteProfesor AS

    PROCEDURE CrearProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    ) AS
    BEGIN
        INSERT INTO Profesor (
            Cedula, IDDepartamento, Nombre, Apellidos, Telefono, CorreoElectronico, FechaInscripcion, TituloAcademico
        ) VALUES (
            p_Cedula, p_IDDepartamento, p_Nombre, p_Apellidos, p_Telefono, p_CorreoElectronico, SYSDATE, p_TituloAcademico
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-21001, 'El profesor con la cédula ' || p_Cedula || ' ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21002, 'Error al crear el profesor: ' || SQLERRM);
    END CrearProfesor;

    PROCEDURE LeerProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_Profesor OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Profesor FOR
        SELECT * FROM Profesor WHERE Cedula = p_Cedula;
    END LeerProfesor;

    PROCEDURE ActualizarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    ) AS
    BEGIN
        UPDATE Profesor
        SET IDDepartamento = p_IDDepartamento,
            Nombre = p_Nombre,
            Apellidos = p_Apellidos,
            Telefono = p_Telefono,
            CorreoElectronico = p_CorreoElectronico,
            TituloAcademico = p_TituloAcademico
        WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-21003, 'El profesor con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21004, 'Error al actualizar el profesor: ' || SQLERRM);
    END ActualizarProfesor;

    PROCEDURE EliminarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE
    ) AS
    BEGIN
        DELETE FROM Profesor WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-21005, 'El profesor con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21006, 'Error al eliminar el profesor: ' || SQLERRM);
    END EliminarProfesor;

END PaqueteProfesor;

CREATE OR REPLACE PACKAGE PaqueteDepartamento AS
    -- Procedimiento para crear un departamento
    PROCEDURE CrearDepartamento(
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    );

    -- Procedimiento para leer un departamento
    PROCEDURE LeerDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_Departamento OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un departamento
    PROCEDURE ActualizarDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    );

    -- Procedimiento para eliminar un departamento
    PROCEDURE EliminarDepartamento(
        p_ID IN Departamento.ID%TYPE
    );
END PaqueteDepartamento;

CREATE OR REPLACE PACKAGE BODY PaqueteDepartamento AS

    PROCEDURE CrearDepartamento(
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    ) AS
    BEGIN
        INSERT INTO Departamento (
            CedulaJefeDepartamento, Nombre, Descripcion
        ) VALUES (
            p_CedulaJefeDepartamento, p_Nombre, p_Descripcion
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22001, 'Error al crear el departamento: ' || SQLERRM);
    END CrearDepartamento;

    PROCEDURE LeerDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_Departamento OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Departamento FOR
        SELECT * FROM Departamento WHERE ID = p_ID;
    END LeerDepartamento;

    PROCEDURE ActualizarDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    ) AS
    BEGIN
        UPDATE Departamento
        SET CedulaJefeDepartamento = p_CedulaJefeDepartamento,
            Nombre = p_Nombre,
            Descripcion = p_Descripcion
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-22002, 'El departamento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22003, 'Error al actualizar el departamento: ' || SQLERRM);
    END ActualizarDepartamento;

    PROCEDURE EliminarDepartamento(
        p_ID IN Departamento.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Departamento WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-22004, 'El departamento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22005, 'Error al eliminar el departamento: ' || SQLERRM);
    END EliminarDepartamento;

END PaqueteDepartamento;

CREATE OR REPLACE PACKAGE PaqueteMateria AS
    -- Procedimiento para crear una materia
    PROCEDURE CrearMateria(
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    );

    -- Procedimiento para leer una materia
    PROCEDURE LeerMateria(
        p_ID IN Materia.ID%TYPE,
        p_Materia OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una materia
    PROCEDURE ActualizarMateria(
        p_ID IN Materia.ID%TYPE,
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    );

    -- Procedimiento para eliminar una materia
    PROCEDURE EliminarMateria(
        p_ID IN Materia.ID%TYPE
    );
END PaqueteMateria;

CREATE OR REPLACE PACKAGE BODY PaqueteMateria AS

    PROCEDURE CrearMateria(
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    ) AS
    BEGIN
        INSERT INTO Materia (
            Nombre, Descripcion, Creditos
        ) VALUES (
            p_Nombre, p_Descripcion, p_Creditos
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23001, 'Error al crear la materia: ' || SQLERRM);
    END CrearMateria;

    PROCEDURE LeerMateria(
        p_ID IN Materia.ID%TYPE,
        p_Materia OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Materia FOR
        SELECT * FROM Materia WHERE ID = p_ID;
    END LeerMateria;

    PROCEDURE ActualizarMateria(
        p_ID IN Materia.ID%TYPE,
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    ) AS
    BEGIN
        UPDATE Materia
        SET Nombre = p_Nombre,
            Descripcion = p_Descripcion,
            Creditos = p_Creditos
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-23002, 'La materia con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23003, 'Error al actualizar la materia: ' || SQLERRM);
    END ActualizarMateria;

    PROCEDURE EliminarMateria(
        p_ID IN Materia.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Materia WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-23004, 'La materia con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23005, 'Error al eliminar la materia: ' || SQLERRM);
    END EliminarMateria;

END PaqueteMateria;

CREATE OR REPLACE PACKAGE PaqueteAsignacion AS
    -- Procedimiento para crear una asignación
    PROCEDURE CrearAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    );

    -- Procedimiento para leer una asignación
    PROCEDURE LeerAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_Asignacion OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una asignación
    PROCEDURE ActualizarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_NuevoSemestre IN Asignacion.Semestre%TYPE,
        p_NuevoAnio IN Asignacion.Anio%TYPE
    );

    -- Procedimiento para eliminar una asignación
    PROCEDURE EliminarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    );
END PaqueteAsignacion;

CREATE OR REPLACE PACKAGE BODY PaqueteAsignacion AS

    PROCEDURE CrearAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        INSERT INTO Asignacion (
            IDMateria, CedulaProfesor, Semestre, Anio
        ) VALUES (
            p_IDMateria, p_CedulaProfesor, p_Semestre, p_Anio
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-24001, 'La asignación ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24002, 'Error al crear la asignación: ' || SQLERRM);
    END CrearAsignacion;

    PROCEDURE LeerAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_Asignacion OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Asignacion FOR
        SELECT * FROM Asignacion
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
    END LeerAsignacion;

    PROCEDURE ActualizarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_NuevoSemestre IN Asignacion.Semestre%TYPE,
        p_NuevoAnio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        UPDATE Asignacion
        SET Semestre = p_NuevoSemestre,
            Anio = p_NuevoAnio
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-24003, 'La asignación no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24004, 'Error al actualizar la asignación: ' || SQLERRM);
    END ActualizarAsignacion;

    PROCEDURE EliminarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        DELETE FROM Asignacion
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-24005, 'La asignación no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24006, 'Error al eliminar la asignación: ' || SQLERRM);
    END EliminarAsignacion;

END PaqueteAsignacion;

CREATE OR REPLACE PACKAGE PaqueteMatricula AS
    -- Procedimiento para crear una matrícula
    PROCEDURE CrearMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    );

    -- Procedimiento para leer las matrículas de un estudiante
    PROCEDURE LeerMatriculasEstudiante(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_Matriculas OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una matrícula
    PROCEDURE ActualizarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE,
        p_NuevoSemestre IN Matricula.Semestre%TYPE,
        p_NuevoAnio IN Matricula.Anio%TYPE
    );

    -- Procedimiento para eliminar una matrícula
    PROCEDURE EliminarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    );
END PaqueteMatricula;

CREATE OR REPLACE PACKAGE BODY PaqueteMatricula AS

    PROCEDURE CrearMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        INSERT INTO Matricula (
            CedulaEstudiante, IDMateria, Semestre, Anio, FechaMatricula
        ) VALUES (
            p_CedulaEstudiante, p_IDMateria, p_Semestre, p_Anio, SYSDATE
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-25001, 'La matrícula ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25002, 'Error al crear la matrícula: ' || SQLERRM);
    END CrearMatricula;

    PROCEDURE LeerMatriculasEstudiante(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_Matriculas OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Matriculas FOR
        SELECT * FROM Matricula WHERE CedulaEstudiante = p_CedulaEstudiante;
    END LeerMatriculasEstudiante;

    PROCEDURE ActualizarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE,
        p_NuevoSemestre IN Matricula.Semestre%TYPE,
        p_NuevoAnio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        UPDATE Matricula
        SET Semestre = p_NuevoSemestre,
            Anio = p_NuevoAnio
        WHERE CedulaEstudiante = p_CedulaEstudiante
          AND IDMateria = p_IDMateria
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-25003, 'La matrícula no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25004, 'Error al actualizar la matrícula: ' || SQLERRM);
    END ActualizarMatricula;

    PROCEDURE EliminarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        DELETE FROM Matricula
        WHERE CedulaEstudiante = p_CedulaEstudiante
          AND IDMateria = p_IDMateria
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-25005, 'La matrícula no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25006, 'Error al eliminar la matrícula: ' || SQLERRM);
    END EliminarMatricula;

END PaqueteMatricula;

CREATE OR REPLACE PACKAGE PaquetePrerrequisitos AS
    -- Procedimiento para crear un prerrequisito
    PROCEDURE CrearPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    );

    -- Procedimiento para leer los prerrequisitos de una materia
    PROCEDURE LeerPrerrequisitosDeMateria(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_Prerrequisitos OUT SYS_REFCURSOR
    );

    -- Procedimiento para eliminar un prerrequisito
    PROCEDURE EliminarPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    );
END PaquetePrerrequisitos;

CREATE OR REPLACE PACKAGE BODY PaquetePrerrequisitos AS

    PROCEDURE CrearPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    ) AS
    BEGIN
        INSERT INTO Prerrequisitos (
            IDMateriaPrincipal, IDMateriaPrerrequisito
        ) VALUES (
            p_IDMateriaPrincipal, p_IDMateriaPrerrequisito
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-26001, 'El prerrequisito ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-26002, 'Error al crear el prerrequisito: ' || SQLERRM);
    END CrearPrerrequisito;

    PROCEDURE LeerPrerrequisitosDeMateria(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_Prerrequisitos OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Prerrequisitos FOR
        SELECT * FROM Prerrequisitos
        WHERE IDMateriaPrincipal = p_IDMateriaPrincipal;
    END LeerPrerrequisitosDeMateria;

    PROCEDURE EliminarPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    ) AS
    BEGIN
        DELETE FROM Prerrequisitos
        WHERE IDMateriaPrincipal = p_IDMateriaPrincipal
          AND IDMateriaPrerrequisito = p_IDMateriaPrerrequisito;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-26003, 'El prerrequisito no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-26004, 'Error al eliminar el prerrequisito: ' || SQLERRM);
    END EliminarPrerrequisito;

END PaquetePrerrequisitos;

CREATE OR REPLACE PACKAGE PaqueteCongelamientos AS
    -- Procedimiento para crear un congelamiento
    PROCEDURE CrearCongelamiento(
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    );

    -- Procedimiento para leer un congelamiento
    PROCEDURE LeerCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_Congelamiento OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un congelamiento
    PROCEDURE ActualizarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    );

    -- Procedimiento para eliminar un congelamiento
    PROCEDURE EliminarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE
    );
END PaqueteCongelamientos;

CREATE OR REPLACE PACKAGE BODY PaqueteCongelamientos AS

    PROCEDURE CrearCongelamiento(
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    ) AS
    BEGIN
        INSERT INTO Congelamientos (
            CedulaEstudiante, Motivo, FechaInicio, FechaFin
        ) VALUES (
            p_CedulaEstudiante, p_Motivo, p_FechaInicio, p_FechaFin
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27001, 'Error al crear el congelamiento: ' || SQLERRM);
    END CrearCongelamiento;

    PROCEDURE LeerCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_Congelamiento OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Congelamiento FOR
        SELECT * FROM Congelamientos WHERE ID = p_ID;
    END LeerCongelamiento;

    PROCEDURE ActualizarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    ) AS
    BEGIN
        UPDATE Congelamientos
        SET CedulaEstudiante = p_CedulaEstudiante,
            Motivo = p_Motivo,
            FechaInicio = p_FechaInicio,
            FechaFin = p_FechaFin
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-27002, 'El congelamiento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27003, 'Error al actualizar el congelamiento: ' || SQLERRM);
    END ActualizarCongelamiento;

    PROCEDURE EliminarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Congelamientos WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-27004, 'El congelamiento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27005, 'Error al eliminar el congelamiento: ' || SQLERRM);
    END EliminarCongelamiento;

END PaqueteCongelamientos;

CREATE OR REPLACE PACKAGE PaqueteDireccion AS
    -- Procedimiento para crear una dirección
    PROCEDURE CrearDireccion(
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    );

    -- Procedimiento para leer una dirección
    PROCEDURE LeerDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_Direccion OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una dirección
    PROCEDURE ActualizarDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    );

    -- Procedimiento para eliminar una dirección
    PROCEDURE EliminarDireccion(
        p_ID IN Direccion.ID%TYPE
    );
END PaqueteDireccion;

CREATE OR REPLACE PACKAGE BODY PaqueteDireccion AS

    PROCEDURE CrearDireccion(
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    ) AS
    BEGIN
        INSERT INTO Direccion (
            CedulaEstudiante, Provincia, Canton, Distrito, DireccionExacta
        ) VALUES (
            p_CedulaEstudiante, p_Provincia, p_Canton, p_Distrito, p_DireccionExacta
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28001, 'Error al crear la dirección: ' || SQLERRM);
    END CrearDireccion;

    PROCEDURE LeerDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_Direccion OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Direccion FOR
        SELECT * FROM Direccion WHERE ID = p_ID;
    END LeerDireccion;

    PROCEDURE ActualizarDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    ) AS
    BEGIN
        UPDATE Direccion
        SET CedulaEstudiante = p_CedulaEstudiante,
            Provincia = p_Provincia,
            Canton = p_Canton,
            Distrito = p_Distrito,
            DireccionExacta = p_DireccionExacta
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-28002, 'La dirección con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28003, 'Error al actualizar la dirección: ' || SQLERRM);
    END ActualizarDireccion;

    PROCEDURE EliminarDireccion(
        p_ID IN Direccion.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Direccion WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-28004, 'La dirección con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28005, 'Error al eliminar la dirección: ' || SQLERRM);
    END EliminarDireccion;

END PaqueteDireccion;

CREATE OR REPLACE PACKAGE PaqueteHorarios AS
    -- Procedimiento para crear un horario
    PROCEDURE CrearHorario(
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    );

    -- Procedimiento para leer un horario
    PROCEDURE LeerHorario(
        p_ID IN Horarios.ID%TYPE,
        p_Horario OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un horario
    PROCEDURE ActualizarHorario(
        p_ID IN Horarios.ID%TYPE,
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    );

    -- Procedimiento para eliminar un horario
    PROCEDURE EliminarHorario(
        p_ID IN Horarios.ID%TYPE
    );
END PaqueteHorarios;

CREATE OR REPLACE PACKAGE BODY PaqueteHorarios AS

    PROCEDURE CrearHorario(
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    ) AS
    BEGIN
        INSERT INTO Horarios (
            IDMateria, Aula, HorarioInicio, HorarioFin, DiaSemana
        ) VALUES (
            p_IDMateria, p_Aula, p_HorarioInicio, p_HorarioFin, p_DiaSemana
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29001, 'Error al crear el horario: ' || SQLERRM);
    END CrearHorario;

    PROCEDURE LeerHorario(
        p_ID IN Horarios.ID%TYPE,
        p_Horario OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Horario FOR
        SELECT * FROM Horarios WHERE ID = p_ID;
    END LeerHorario;

    PROCEDURE ActualizarHorario(
        p_ID IN Horarios.ID%TYPE,
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    ) AS
    BEGIN
        UPDATE Horarios
        SET IDMateria = p_IDMateria,
            Aula = p_Aula,
            HorarioInicio = p_HorarioInicio,
            HorarioFin = p_HorarioFin,
            DiaSemana = p_DiaSemana
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-29002, 'El horario con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29003, 'Error al actualizar el horario: ' || SQLERRM);
    END ActualizarHorario;

    PROCEDURE EliminarHorario(
        p_ID IN Horarios.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Horarios WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-29004, 'El horario con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29005, 'Error al eliminar el horario: ' || SQLERRM);
    END EliminarHorario;

END PaqueteHorarios;


--creación de FUNCIONES 
-- Función 1: Total de estudiantes registrados
CREATE OR REPLACE FUNCTION TotalEstudiantesRegistrados RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30001, 'Error al obtener total de estudiantes registrados: ' || SQLERRM);
END TotalEstudiantesRegistrados;
/

-- Función 2: Estudiantes activos
CREATE OR REPLACE FUNCTION TotalEstudiantesActivos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante WHERE Estado = 'activo';
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30002, 'Error al obtener total de estudiantes activos: ' || SQLERRM);
END TotalEstudiantesActivos;
/

-- Función 3: Estudiantes inactivos
CREATE OR REPLACE FUNCTION TotalEstudiantesInactivos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante WHERE Estado = 'inactivo';
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30003, 'Error al obtener total de estudiantes inactivos: ' || SQLERRM);
END TotalEstudiantesInactivos;
/

-- Función 4: Edad promedio de los estudiantes
CREATE OR REPLACE FUNCTION EdadPromedioEstudiantes RETURN NUMBER IS
    v_EdadPromedio NUMBER;
BEGIN
    SELECT AVG(FLOOR(MONTHS_BETWEEN(SYSDATE, FechaNacimiento) / 12))
    INTO v_EdadPromedio
    FROM Estudiante
    WHERE Estado = 'activo';
    RETURN v_EdadPromedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30004, 'Error al calcular edad promedio de estudiantes: ' || SQLERRM);
END EdadPromedioEstudiantes;
/

-- Función 5: Estudiantes con matrícula activa
CREATE OR REPLACE FUNCTION EstudiantesConMatriculaActiva RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(DISTINCT CedulaEstudiante) INTO v_Total FROM Matricula;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30005, 'Error al obtener estudiantes con matrícula activa: ' || SQLERRM);
END EstudiantesConMatriculaActiva;
/

-- Función 6: Total de profesores registrados
CREATE OR REPLACE FUNCTION TotalProfesoresRegistrados RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Profesor;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30006, 'Error al obtener total de profesores registrados: ' || SQLERRM);
END TotalProfesoresRegistrados;
/

-- Función 7: Materias asignadas
CREATE OR REPLACE FUNCTION TotalMateriasAsignadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Asignacion;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30007, 'Error al obtener total de materias asignadas: ' || SQLERRM);
END TotalMateriasAsignadas;
/

-- Función 8: Promedio de materias por profesor
CREATE OR REPLACE FUNCTION PromedioMateriasPorProfesor RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(MateriasAsignadas) INTO v_Promedio
    FROM (
        SELECT COUNT(*) AS MateriasAsignadas
        FROM Asignacion
        GROUP BY CedulaProfesor
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30008, 'Error al calcular promedio de materias por profesor: ' || SQLERRM);
END PromedioMateriasPorProfesor;
/

-- Función 9: Profesores con titulaciones avanzadas
CREATE OR REPLACE FUNCTION ProfesoresConTitulacionesAvanzadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM Profesor
    WHERE LOWER(TituloAcademico) IN ('maestría', 'maestria', 'doctorado');
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30009, 'Error al obtener profesores con titulaciones avanzadas: ' || SQLERRM);
END ProfesoresConTitulacionesAvanzadas;
/

-- Función 10: Carga horaria promedio por profesor
CREATE OR REPLACE FUNCTION CargaHorariaPromedioPorProfesor RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(TotalHoras) INTO v_Promedio
    FROM (
        SELECT P.Cedula, SUM(
            EXTRACT(HOUR FROM (H.HorarioFin - H.HorarioInicio)) +
            EXTRACT(MINUTE FROM (H.HorarioFin - H.HorarioInicio)) / 60
        ) AS TotalHoras
        FROM Horarios H
        INNER JOIN Asignacion A ON H.IDMateria = A.IDMateria
        INNER JOIN Profesor P ON A.CedulaProfesor = P.Cedula
        GROUP BY P.Cedula
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30010, 'Error al calcular carga horaria promedio por profesor: ' || SQLERRM);
END CargaHorariaPromedioPorProfesor;
/

-- Función 11: Total de materias ofertadas
CREATE OR REPLACE FUNCTION TotalMateriasOfertadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Materia;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30011, 'Error al obtener total de materias ofertadas: ' || SQLERRM);
END TotalMateriasOfertadas;
/

-- Función 12: Materias sin prerrequisitos
CREATE OR REPLACE FUNCTION TotalMateriasSinPrerrequisitos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM Materia M
    WHERE NOT EXISTS (
        SELECT 1 FROM Prerrequisitos PR WHERE PR.IDMateriaPrincipal = M.ID
    );
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30012, 'Error al obtener total de materias sin prerrequisitos: ' || SQLERRM);
END TotalMateriasSinPrerrequisitos;
/

-- Función 13: Materias con cupo disponible
CREATE OR REPLACE FUNCTION TotalMateriasConCupoDisponible(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER,
    p_CupoMaximo IN NUMBER DEFAULT 30
) RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM (
        SELECT M.ID, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID
        HAVING COUNT(DISTINCT MT.CedulaEstudiante) < p_CupoMaximo
    );
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30013, 'Error al obtener materias con cupo disponible: ' || SQLERRM);
END TotalMateriasConCupoDisponible;
/

-- Función 14: Promedio de estudiantes por materia
CREATE OR REPLACE FUNCTION PromedioEstudiantesPorMateria(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER
) RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(NumEstudiantes) INTO v_Promedio
    FROM (
        SELECT M.ID, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30014, 'Error al calcular promedio de estudiantes por materia: ' || SQLERRM);
END PromedioEstudiantesPorMateria;
/

-- Función 15: Materias más demandadas
CREATE OR REPLACE FUNCTION MateriasMasDemandadas(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER,
    p_TopN IN NUMBER
) RETURN SYS_REFCURSOR IS
    v_Materias SYS_REFCURSOR;
BEGIN
    OPEN v_Materias FOR
    SELECT *
    FROM (
        SELECT M.ID, M.Nombre, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID, M.Nombre
        ORDER BY NumEstudiantes DESC
    )
    WHERE ROWNUM <= p_TopN;
    RETURN v_Materias;
END MateriasMasDemandadas;

--Creación de 10 VISTAS 
--Vista 1: VistaEstudiantesActivos
CREATE OR REPLACE VIEW VistaEstudiantesActivos AS
SELECT
    Cedula,
    Nombre,
    Apellidos,
    Telefono,
    FechaNacimiento,
    CorreoElectronico,
    FechaInscripcion
FROM Estudiante
WHERE Estado = 'activo';

--

Pensado sobre durante 12 segundos
¡Muy bien! Continuaremos con las 10 vistas optimizadas, proporcionándolas en grupos de 5 en 5, incluyendo una breve descripción y el código completo de cada una. Aseguraré que todo sea funcional y verificado para que puedas implementarlo en tu proyecto.

Primer Grupo de 5 Vistas
Vista 1: VistaEstudiantesActivos
Descripción: Muestra todos los estudiantes que están activos en el sistema, incluyendo sus datos personales.

sql
Copiar código
CREATE OR REPLACE VIEW VistaEstudiantesActivos AS
SELECT
    Cedula,
    Nombre,
    Apellidos,
    Telefono,
    FechaNacimiento,
    CorreoElectronico,
    FechaInscripcion
FROM Estudiante
WHERE Estado = 'activo';

--Vista 2: VistaProfesoresPorDepartamento
CREATE OR REPLACE VIEW VistaProfesoresPorDepartamento AS
SELECT
    D.ID AS IDDepartamento,
    D.Nombre AS NombreDepartamento,
    P.Cedula AS CedulaProfesor,
    P.Nombre AS NombreProfesor,
    P.Apellidos AS ApellidosProfesor,
    P.CorreoElectronico,
    P.TituloAcademico
FROM Profesor P
INNER JOIN Departamento D ON P.IDDepartamento = D.ID;


--Vista 3: VistaMateriasConPrerrequisitos
CREATE OR REPLACE VIEW VistaMateriasConPrerrequisitos AS
SELECT
    MP.ID AS IDMateriaPrincipal,
    MP.Nombre AS NombreMateriaPrincipal,
    MPR.ID AS IDMateriaPrerrequisito,
    MPR.Nombre AS NombreMateriaPrerrequisito
FROM Prerrequisitos PR
INNER JOIN Materia MP ON PR.IDMateriaPrincipal = MP.ID
INNER JOIN Materia MPR ON PR.IDMateriaPrerrequisito = MPR.ID;

--Vista 4: VistaHorariosCompleto
CREATE OR REPLACE VIEW VistaHorariosCompleto AS
SELECT
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    H.Aula,
    H.DiaSemana,
    TO_CHAR(H.HorarioInicio, 'HH24:MI') AS HorarioInicio,
    TO_CHAR(H.HorarioFin, 'HH24:MI') AS HorarioFin,
    P.Cedula AS CedulaProfesor,
    P.Nombre || ' ' || P.Apellidos AS NombreProfesor
FROM Horarios H
INNER JOIN Materia M ON H.IDMateria = M.ID
LEFT JOIN Asignacion A ON M.ID = A.IDMateria
LEFT JOIN Profesor P ON A.CedulaProfesor = P.Cedula;

--Vista 5: VistaMatriculasPorEstudiante
CREATE OR REPLACE VIEW VistaMatriculasPorEstudiante AS
SELECT
    E.Cedula AS CedulaEstudiante,
    E.Nombre || ' ' || E.Apellidos AS NombreEstudiante,
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    MT.Semestre,
    MT.Anio,
    MT.FechaMatricula
FROM Matricula MT
INNER JOIN Estudiante E ON MT.CedulaEstudiante = E.Cedula
INNER JOIN Materia M ON MT.IDMateria = M.ID;

--Vista 6: VistaEstudiantesConDireccion
CREATE OR REPLACE VIEW VistaEstudiantesConDireccion AS
SELECT
    E.Cedula,
    E.Nombre,
    E.Apellidos,
    D.Provincia,
    D.Canton,
    D.Distrito,
    D.DireccionExacta
FROM Estudiante E
LEFT JOIN Direccion D ON E.Cedula = D.CedulaEstudiante;


--Vista 7: VistaCongelamientosActivos
CREATE OR REPLACE VIEW VistaCongelamientosActivos AS
SELECT
    C.ID,
    C.CedulaEstudiante,
    E.Nombre || ' ' || E.Apellidos AS NombreEstudiante,
    C.Motivo,
    C.FechaInicio
FROM Congelamientos C
INNER JOIN Estudiante E ON C.CedulaEstudiante = E.Cedula
WHERE C.FechaFin IS NULL;

--Vista 8: VistaAsignacionesProfesor
CREATE OR REPLACE VIEW VistaAsignacionesProfesor AS
SELECT
    P.Cedula AS CedulaProfesor,
    P.Nombre || ' ' || P.Apellidos AS NombreProfesor,
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    A.Semestre,
    A.Anio
FROM Asignacion A
INNER JOIN Profesor P ON A.CedulaProfesor = P.Cedula
INNER JOIN Materia M ON A.IDMateria = M.ID;

--Vista 9: VistaPrerrequisitosPendientesEstudiante
CREATE OR REPLACE VIEW VistaPrerrequisitosPendientesEstudiante AS
SELECT
    E.Cedula AS CedulaEstudiante,
    E.Nombre || ' ' || E.Apellidos AS NombreEstudiante,
    MPR.ID AS IDMateriaPrerrequisito,
    MPR.Nombre AS NombreMateriaPrerrequisito
FROM Estudiante E
CROSS JOIN Prerrequisitos PR
INNER JOIN Materia MPR ON PR.IDMateriaPrerrequisito = MPR.ID
WHERE NOT EXISTS (
    SELECT 1
    FROM Matricula MT
    WHERE MT.CedulaEstudiante = E.Cedula
    AND MT.IDMateria = PR.IDMateriaPrerrequisito
);

--Vista 10: VistaEstudiantesPorMateria
CREATE OR REPLACE VIEW VistaEstudiantesPorMateria AS
SELECT
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    E.Cedula AS CedulaEstudiante,
    E.Nombre || ' ' || E.Apellidos AS NombreEstudiante,
    MT.Semestre,
    MT.Anio
FROM Matricula MT
INNER JOIN Materia M ON MT.IDMateria = M.ID
INNER JOIN Estudiante E ON MT.CedulaEstudiante = E.Cedula;


--Creacion de Triggers 
--Trigger 1: Actualizar Estado del Estudiante al Registrar un Congelamiento
CREATE OR REPLACE TRIGGER trg_EstadoEstudiante_Congelamiento
AFTER INSERT ON Congelamientos
FOR EACH ROW
BEGIN
    UPDATE Estudiante
    SET Estado = 'inactivo'
    WHERE Cedula = :NEW.CedulaEstudiante;
END;

--Trigger 2: Validar Prerrequisitos al Matricular una Materia
CREATE OR REPLACE TRIGGER trg_ValidarPrerrequisitos_Matricula
BEFORE INSERT ON Matricula
FOR EACH ROW
DECLARE
    v_Count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_Count
    FROM Prerrequisitos PR
    WHERE PR.IDMateriaPrincipal = :NEW.IDMateria
    AND NOT EXISTS (
        SELECT 1
        FROM Matricula MT
        WHERE MT.CedulaEstudiante = :NEW.CedulaEstudiante
        AND MT.IDMateria = PR.IDMateriaPrerrequisito
    );

    IF v_Count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El estudiante no cumple con los prerrequisitos para esta materia.');
    END IF;
END;

--Trigger 3: Prevenir Solapamiento de Horarios en el Mismo Aula
CREATE OR REPLACE TRIGGER trg_PrevenirSolapamiento_Horarios
BEFORE INSERT OR UPDATE ON Horarios
FOR EACH ROW
DECLARE
    v_Count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_Count
    FROM Horarios H
    WHERE H.Aula = :NEW.Aula
    AND H.DiaSemana = :NEW.DiaSemana
    AND H.ID <> NVL(:OLD.ID, 0)
    AND (
        (:NEW.HorarioInicio BETWEEN H.HorarioInicio AND H.HorarioFin)
        OR
        (:NEW.HorarioFin BETWEEN H.HorarioInicio AND H.HorarioFin)
        OR
        (H.HorarioInicio BETWEEN :NEW.HorarioInicio AND :NEW.HorarioFin)
    );

    IF v_Count > 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Existe un horario que se solapa en el mismo aula y día.');
    END IF;
END;

--Trigger 4: Registrar Historial de Cambios en la Tabla Matricula
-- Creación de la tabla de auditoría
CREATE TABLE Matricula_Historial (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    IDMateria NUMBER,
    Semestre NUMBER,
    Anio NUMBER,
    Operacion VARCHAR2(10),
    Usuario VARCHAR2(50),
    FechaOperacion DATE
);
/

-- Trigger para registrar el historial
CREATE OR REPLACE TRIGGER trg_Auditoria_Matricula
AFTER INSERT OR UPDATE OR DELETE ON Matricula
FOR EACH ROW
BEGIN
    INSERT INTO Matricula_Historial (
        CedulaEstudiante, IDMateria, Semestre, Anio, Operacion, Usuario, FechaOperacion
    ) VALUES (
        COALESCE(:NEW.CedulaEstudiante, :OLD.CedulaEstudiante),
        COALESCE(:NEW.IDMateria, :OLD.IDMateria),
        COALESCE(:NEW.Semestre, :OLD.Semestre),
        COALESCE(:NEW.Anio, :OLD.Anio),
        CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING THEN 'UPDATE'
            WHEN DELETING THEN 'DELETE'
        END,
        USER,
        SYSDATE
    );
END;

--Trigger 5: Actualizar Fecha de Fin de Congelamiento al Reactivar Estudiante
CREATE OR REPLACE TRIGGER trg_ActualizarCongelamiento_Estudiante
AFTER UPDATE OF Estado ON Estudiante
FOR EACH ROW
BEGIN
    IF :OLD.Estado = 'inactivo' AND :NEW.Estado = 'activo' THEN
        UPDATE Congelamientos
        SET FechaFin = SYSDATE
        WHERE CedulaEstudiante = :NEW.Cedula
        AND FechaFin IS NULL;
    END IF;
END;

--Creacion de CURSORES
--Cursor 1: Listar Materias sin Prerrequisitos
CREATE OR REPLACE FUNCTION ListarMateriasSinPrerrequisitos RETURN SYS_REFCURSOR IS
    v_Materias SYS_REFCURSOR;
BEGIN
    OPEN v_Materias FOR
    SELECT M.ID, M.Nombre, M.Creditos
    FROM Materia M
    WHERE NOT EXISTS (
        SELECT 1
        FROM Prerrequisitos PR
        WHERE PR.IDMateriaPrincipal = M.ID
    );
    
    RETURN v_Materias;
END ListarMateriasSinPrerrequisitos;


--Cursor 2: Listar Estudiantes con Congelamientos Activos
CREATE OR REPLACE PROCEDURE ListarEstudiantesCongelados(
    p_Estudiantes OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_Estudiantes FOR
    SELECT E.Cedula, E.Nombre, E.Apellidos, C.FechaInicio
    FROM Estudiante E
    INNER JOIN Congelamientos C ON E.Cedula = C.CedulaEstudiante
    WHERE C.FechaFin IS NULL;
END ListarEstudiantesCongelados;

--Cursor 3: Listar Profesores y sus Materias Asignadas
CREATE OR REPLACE FUNCTION ListarProfesoresConMaterias RETURN SYS_REFCURSOR IS
    v_ProfesoresMaterias SYS_REFCURSOR;
BEGIN
    OPEN v_ProfesoresMaterias FOR
    SELECT P.Cedula, P.Nombre || ' ' || P.Apellidos AS NombreProfesor, M.ID AS IDMateria, M.Nombre AS NombreMateria
    FROM Profesor P
    INNER JOIN Asignacion A ON P.Cedula = A.CedulaProfesor
    INNER JOIN Materia M ON A.IDMateria = M.ID;
    
    RETURN v_ProfesoresMaterias;
END ListarProfesoresConMaterias;

--Cursor 4: Listar Direcciones por Provincia
CREATE OR REPLACE PROCEDURE ListarDireccionesPorProvincia(
    p_Provincia IN Direccion.Provincia%TYPE,
    p_Direcciones OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_Direcciones FOR
    SELECT D.CedulaEstudiante, E.Nombre || ' ' || E.Apellidos AS NombreEstudiante, D.Canton, D.Distrito, D.DireccionExacta
    FROM Direccion D
    INNER JOIN Estudiante E ON D.CedulaEstudiante = E.Cedula
    WHERE D.Provincia = p_Provincia;
END ListarDireccionesPorProvincia;


--Cursor 5: Obtener Historial de Matriculas de un Estudiante
CREATE OR REPLACE FUNCTION ObtenerHistorialMatriculas(
    p_CedulaEstudiante IN Estudiante.Cedula%TYPE
) RETURN SYS_REFCURSOR IS
    v_Historial SYS_REFCURSOR;
BEGIN
    OPEN v_Historial FOR
    SELECT M.ID AS IDMateria, M.Nombre AS NombreMateria, MT.Semestre, MT.Anio, MT.FechaMatricula
    FROM Matricula MT
    INNER JOIN Materia M ON MT.IDMateria = M.ID
    WHERE MT.CedulaEstudiante = p_CedulaEstudiante
    ORDER BY MT.Anio DESC, MT.Semestre DESC;
    
    RETURN v_Historial;
END ObtenerHistorialMatriculas;

/*
Estructuras Avanzadas:

25 procedimientos almacenados.                   implementados 40
15 funciones adicionales.                        implementados 15
10 vistas optimizadas.                           implementados 10
10 paquetes organizadores.                       implementados 10
5 triggers específicos.                          implementados 5
15 cursores para manejo de datos complejos.      implementados 19
*/