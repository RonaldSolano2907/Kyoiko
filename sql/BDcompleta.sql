--creación de tablas

CREATE TABLE Usuarios (
    Usuario VARCHAR2(50) PRIMARY KEY,
    Clave VARCHAR2(50) NOT NULL,
    Rol VARCHAR2(20) DEFAULT 'admin' 
);

-- Insertamos un usuario
INSERT INTO Usuarios (Usuario, Clave, Rol)
VALUES ('admin', '12345', 'admin');


CREATE TABLE Estudiante (
    Cedula VARCHAR2(50) PRIMARY KEY,
    Nombre VARCHAR2(50) NOT NULL,
    Apellidos VARCHAR2(50) NOT NULL,
    Telefono VARCHAR2(15),
    FechaNacimiento DATE,
    CorreoElectronico VARCHAR2(100),
    FechaInscripcion DATE,
    Estado VARCHAR2(10) DEFAULT 'activo' CHECK (Estado IN ('activo', 'inactivo'))
);

CREATE TABLE Profesor (
    Cedula VARCHAR2(50) PRIMARY KEY,
    IDDepartamento NUMBER,
    Nombre VARCHAR2(50) NOT NULL,
    Apellidos VARCHAR2(50) NOT NULL,
    Telefono VARCHAR2(15),
    CorreoElectronico VARCHAR2(100),
    FechaInscripcion DATE,
    TituloAcademico VARCHAR2(100),
    CONSTRAINT FK_Profesor_Departamento FOREIGN KEY (IDDepartamento) REFERENCES Departamento(ID)
);

CREATE TABLE Departamento (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaJefeDepartamento VARCHAR2(50),
    Nombre VARCHAR2(100) NOT NULL,
    Descripcion CLOB,
    CONSTRAINT FK_Departamento_Profesor FOREIGN KEY (CedulaJefeDepartamento) REFERENCES Profesor(Cedula)
);

CREATE TABLE Materia (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Nombre VARCHAR2(100) NOT NULL,
    Descripcion CLOB,
    Creditos NUMBER NOT NULL
);

CREATE TABLE Asignacion (
    IDMateria NUMBER,
    CedulaProfesor VARCHAR2(50),
    Semestre NUMBER(4),
    Anio NUMBER(4),
    CONSTRAINT PK_Asignacion PRIMARY KEY (IDMateria, CedulaProfesor, Semestre, Anio),
    CONSTRAINT FK_Asignacion_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID),
    CONSTRAINT FK_Asignacion_Profesor FOREIGN KEY (CedulaProfesor) REFERENCES Profesor(Cedula)
);

CREATE TABLE Matricula (
    CedulaEstudiante VARCHAR2(50),
    IDMateria NUMBER,
    Semestre NUMBER,
    Anio NUMBER,
    FechaMatricula DATE,
    CONSTRAINT PK_Matricula PRIMARY KEY (CedulaEstudiante, IDMateria, Semestre, Anio),
    CONSTRAINT FK_Matricula_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula),
    CONSTRAINT FK_Matricula_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID)
);

CREATE TABLE Prerrequisitos (
    IDMateriaPrincipal NUMBER,
    IDMateriaPrerrequisito NUMBER,
    CONSTRAINT PK_Prerrequisitos PRIMARY KEY (IDMateriaPrincipal, IDMateriaPrerrequisito),
    CONSTRAINT FK_Prerrequisitos_Principal FOREIGN KEY (IDMateriaPrincipal) REFERENCES Materia(ID),
    CONSTRAINT FK_Prerrequisitos_Prerrequisito FOREIGN KEY (IDMateriaPrerrequisito) REFERENCES Materia(ID)
);

CREATE TABLE Congelamientos (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    Motivo CLOB,
    FechaInicio DATE,
    FechaFin DATE,
    CONSTRAINT FK_Congelamientos_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula)
);

CREATE TABLE Direccion (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    Provincia VARCHAR2(50),
    Canton VARCHAR2(50),
    Distrito VARCHAR2(50),
    DireccionExacta CLOB,
    CONSTRAINT FK_Direccion_Estudiante FOREIGN KEY (CedulaEstudiante) REFERENCES Estudiante(Cedula)
);

CREATE TABLE Horarios (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    IDMateria NUMBER,
    Aula VARCHAR2(20),
    HorarioInicio TIMESTAMP,
    HorarioFin TIMESTAMP,
    DiaSemana VARCHAR2(10) CHECK (DiaSemana IN ('Lunes', 'Martes', 'Miercoles', 'Jueves', 'Viernes', 'Sabado', 'Domingo')),
    CONSTRAINT FK_Horarios_Materia FOREIGN KEY (IDMateria) REFERENCES Materia(ID)
);


--Creación de PROCEDIMIENTOS CRUD en PAQUETES

CREATE OR REPLACE PACKAGE PaqueteEstudiante AS

    PROCEDURE CrearEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE
    );

    PROCEDURE LeerEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Estudiante OUT SYS_REFCURSOR
    );

    PROCEDURE ActualizarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE,
        p_Estado IN Estudiante.Estado%TYPE
    );


    PROCEDURE EliminarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE
    );
END PaqueteEstudiante;

--Implementación del Paquete PaqueteEstudiante

CREATE OR REPLACE PACKAGE BODY PaqueteEstudiante AS

    PROCEDURE CrearEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE
    ) AS
    BEGIN
        INSERT INTO Estudiante (
            Cedula, Nombre, Apellidos, Telefono, FechaNacimiento, CorreoElectronico, FechaInscripcion, Estado
        ) VALUES (
            p_Cedula, p_Nombre, p_Apellidos, p_Telefono, p_FechaNacimiento, p_CorreoElectronico, SYSDATE, 'activo'
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-20001, 'El estudiante con la cédula ' || p_Cedula || ' ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Error al crear el estudiante: ' || SQLERRM);
    END CrearEstudiante;

    PROCEDURE LeerEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Estudiante OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Estudiante FOR
        SELECT * FROM Estudiante WHERE Cedula = p_Cedula;
    END LeerEstudiante;

    PROCEDURE ActualizarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE,
        p_Nombre IN Estudiante.Nombre%TYPE,
        p_Apellidos IN Estudiante.Apellidos%TYPE,
        p_Telefono IN Estudiante.Telefono%TYPE,
        p_FechaNacimiento IN Estudiante.FechaNacimiento%TYPE,
        p_CorreoElectronico IN Estudiante.CorreoElectronico%TYPE,
        p_Estado IN Estudiante.Estado%TYPE
    ) AS
    BEGIN
        UPDATE Estudiante
        SET Nombre = p_Nombre,
            Apellidos = p_Apellidos,
            Telefono = p_Telefono,
            FechaNacimiento = p_FechaNacimiento,
            CorreoElectronico = p_CorreoElectronico,
            Estado = p_Estado
        WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, 'El estudiante con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20004, 'Error al actualizar el estudiante: ' || SQLERRM);
    END ActualizarEstudiante;

    PROCEDURE EliminarEstudiante(
        p_Cedula IN Estudiante.Cedula%TYPE
    ) AS
    BEGIN
        DELETE FROM Estudiante WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20005, 'El estudiante con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20006, 'Error al eliminar el estudiante: ' || SQLERRM);
    END EliminarEstudiante;

END PaqueteEstudiante;

CREATE OR REPLACE PACKAGE PaqueteProfesor AS
    
    PROCEDURE CrearProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    );

    
    PROCEDURE LeerProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_Profesor OUT SYS_REFCURSOR
    );

   
    PROCEDURE ActualizarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    );

   
    PROCEDURE EliminarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE
    );
END PaqueteProfesor;

CREATE OR REPLACE PACKAGE BODY PaqueteProfesor AS

    PROCEDURE CrearProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    ) AS
    BEGIN
        INSERT INTO Profesor (
            Cedula, IDDepartamento, Nombre, Apellidos, Telefono, CorreoElectronico, FechaInscripcion, TituloAcademico
        ) VALUES (
            p_Cedula, p_IDDepartamento, p_Nombre, p_Apellidos, p_Telefono, p_CorreoElectronico, SYSDATE, p_TituloAcademico
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-21001, 'El profesor con la cédula ' || p_Cedula || ' ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21002, 'Error al crear el profesor: ' || SQLERRM);
    END CrearProfesor;

    PROCEDURE LeerProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_Profesor OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Profesor FOR
        SELECT * FROM Profesor WHERE Cedula = p_Cedula;
    END LeerProfesor;

    PROCEDURE ActualizarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE,
        p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
        p_Nombre IN Profesor.Nombre%TYPE,
        p_Apellidos IN Profesor.Apellidos%TYPE,
        p_Telefono IN Profesor.Telefono%TYPE,
        p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
        p_TituloAcademico IN Profesor.TituloAcademico%TYPE
    ) AS
    BEGIN
        UPDATE Profesor
        SET IDDepartamento = p_IDDepartamento,
            Nombre = p_Nombre,
            Apellidos = p_Apellidos,
            Telefono = p_Telefono,
            CorreoElectronico = p_CorreoElectronico,
            TituloAcademico = p_TituloAcademico
        WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-21003, 'El profesor con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21004, 'Error al actualizar el profesor: ' || SQLERRM);
    END ActualizarProfesor;

    PROCEDURE EliminarProfesor(
        p_Cedula IN Profesor.Cedula%TYPE
    ) AS
    BEGIN
        DELETE FROM Profesor WHERE Cedula = p_Cedula;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-21005, 'El profesor con la cédula ' || p_Cedula || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-21006, 'Error al eliminar el profesor: ' || SQLERRM);
    END EliminarProfesor;

END PaqueteProfesor;

CREATE OR REPLACE PACKAGE PaqueteDepartamento AS
    -- Procedimiento para crear un departamento
    PROCEDURE CrearDepartamento(
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    );

    -- Procedimiento para leer un departamento
    PROCEDURE LeerDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_Departamento OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un departamento
    PROCEDURE ActualizarDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    );

    -- Procedimiento para eliminar un departamento
    PROCEDURE EliminarDepartamento(
        p_ID IN Departamento.ID%TYPE
    );
END PaqueteDepartamento;

CREATE OR REPLACE PACKAGE BODY PaqueteDepartamento AS

    PROCEDURE CrearDepartamento(
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    ) AS
    BEGIN
        INSERT INTO Departamento (
            CedulaJefeDepartamento, Nombre, Descripcion
        ) VALUES (
            p_CedulaJefeDepartamento, p_Nombre, p_Descripcion
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22001, 'Error al crear el departamento: ' || SQLERRM);
    END CrearDepartamento;

    PROCEDURE LeerDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_Departamento OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Departamento FOR
        SELECT * FROM Departamento WHERE ID = p_ID;
    END LeerDepartamento;

    PROCEDURE ActualizarDepartamento(
        p_ID IN Departamento.ID%TYPE,
        p_CedulaJefeDepartamento IN Departamento.CedulaJefeDepartamento%TYPE,
        p_Nombre IN Departamento.Nombre%TYPE,
        p_Descripcion IN Departamento.Descripcion%TYPE
    ) AS
    BEGIN
        UPDATE Departamento
        SET CedulaJefeDepartamento = p_CedulaJefeDepartamento,
            Nombre = p_Nombre,
            Descripcion = p_Descripcion
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-22002, 'El departamento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22003, 'Error al actualizar el departamento: ' || SQLERRM);
    END ActualizarDepartamento;

    PROCEDURE EliminarDepartamento(
        p_ID IN Departamento.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Departamento WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-22004, 'El departamento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-22005, 'Error al eliminar el departamento: ' || SQLERRM);
    END EliminarDepartamento;

END PaqueteDepartamento;

CREATE OR REPLACE PACKAGE PaqueteMateria AS
    -- Procedimiento para crear una materia
    PROCEDURE CrearMateria(
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    );

    -- Procedimiento para leer una materia
    PROCEDURE LeerMateria(
        p_ID IN Materia.ID%TYPE,
        p_Materia OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una materia
    PROCEDURE ActualizarMateria(
        p_ID IN Materia.ID%TYPE,
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    );

    -- Procedimiento para eliminar una materia
    PROCEDURE EliminarMateria(
        p_ID IN Materia.ID%TYPE
    );
END PaqueteMateria;

CREATE OR REPLACE PACKAGE BODY PaqueteMateria AS

    PROCEDURE CrearMateria(
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    ) AS
    BEGIN
        INSERT INTO Materia (
            Nombre, Descripcion, Creditos
        ) VALUES (
            p_Nombre, p_Descripcion, p_Creditos
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23001, 'Error al crear la materia: ' || SQLERRM);
    END CrearMateria;

    PROCEDURE LeerMateria(
        p_ID IN Materia.ID%TYPE,
        p_Materia OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Materia FOR
        SELECT * FROM Materia WHERE ID = p_ID;
    END LeerMateria;

    PROCEDURE ActualizarMateria(
        p_ID IN Materia.ID%TYPE,
        p_Nombre IN Materia.Nombre%TYPE,
        p_Descripcion IN Materia.Descripcion%TYPE,
        p_Creditos IN Materia.Creditos%TYPE
    ) AS
    BEGIN
        UPDATE Materia
        SET Nombre = p_Nombre,
            Descripcion = p_Descripcion,
            Creditos = p_Creditos
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-23002, 'La materia con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23003, 'Error al actualizar la materia: ' || SQLERRM);
    END ActualizarMateria;

    PROCEDURE EliminarMateria(
        p_ID IN Materia.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Materia WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-23004, 'La materia con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-23005, 'Error al eliminar la materia: ' || SQLERRM);
    END EliminarMateria;

END PaqueteMateria;

CREATE OR REPLACE PACKAGE PaqueteAsignacion AS
    -- Procedimiento para crear una asignación
    PROCEDURE CrearAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    );

    -- Procedimiento para leer una asignación
    PROCEDURE LeerAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_Asignacion OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una asignación
    PROCEDURE ActualizarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_NuevoSemestre IN Asignacion.Semestre%TYPE,
        p_NuevoAnio IN Asignacion.Anio%TYPE
    );

    -- Procedimiento para eliminar una asignación
    PROCEDURE EliminarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    );
END PaqueteAsignacion;

CREATE OR REPLACE PACKAGE BODY PaqueteAsignacion AS

    PROCEDURE CrearAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        INSERT INTO Asignacion (
            IDMateria, CedulaProfesor, Semestre, Anio
        ) VALUES (
            p_IDMateria, p_CedulaProfesor, p_Semestre, p_Anio
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-24001, 'La asignación ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24002, 'Error al crear la asignación: ' || SQLERRM);
    END CrearAsignacion;

    PROCEDURE LeerAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_Asignacion OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Asignacion FOR
        SELECT * FROM Asignacion
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
    END LeerAsignacion;

    PROCEDURE ActualizarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE,
        p_NuevoSemestre IN Asignacion.Semestre%TYPE,
        p_NuevoAnio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        UPDATE Asignacion
        SET Semestre = p_NuevoSemestre,
            Anio = p_NuevoAnio
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-24003, 'La asignación no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24004, 'Error al actualizar la asignación: ' || SQLERRM);
    END ActualizarAsignacion;

    PROCEDURE EliminarAsignacion(
        p_IDMateria IN Asignacion.IDMateria%TYPE,
        p_CedulaProfesor IN Asignacion.CedulaProfesor%TYPE,
        p_Semestre IN Asignacion.Semestre%TYPE,
        p_Anio IN Asignacion.Anio%TYPE
    ) AS
    BEGIN
        DELETE FROM Asignacion
        WHERE IDMateria = p_IDMateria
          AND CedulaProfesor = p_CedulaProfesor
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-24005, 'La asignación no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-24006, 'Error al eliminar la asignación: ' || SQLERRM);
    END EliminarAsignacion;

END PaqueteAsignacion;

CREATE OR REPLACE PACKAGE PaqueteMatricula AS
    -- Procedimiento para crear una matrícula
    PROCEDURE CrearMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    );

    -- Procedimiento para leer las matrículas de un estudiante
    PROCEDURE LeerMatriculasEstudiante(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_Matriculas OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una matrícula
    PROCEDURE ActualizarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE,
        p_NuevoSemestre IN Matricula.Semestre%TYPE,
        p_NuevoAnio IN Matricula.Anio%TYPE
    );

    -- Procedimiento para eliminar una matrícula
    PROCEDURE EliminarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    );
END PaqueteMatricula;

CREATE OR REPLACE PACKAGE BODY PaqueteMatricula AS

    PROCEDURE CrearMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        INSERT INTO Matricula (
            CedulaEstudiante, IDMateria, Semestre, Anio, FechaMatricula
        ) VALUES (
            p_CedulaEstudiante, p_IDMateria, p_Semestre, p_Anio, SYSDATE
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-25001, 'La matrícula ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25002, 'Error al crear la matrícula: ' || SQLERRM);
    END CrearMatricula;

    PROCEDURE LeerMatriculasEstudiante(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_Matriculas OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Matriculas FOR
        SELECT * FROM Matricula WHERE CedulaEstudiante = p_CedulaEstudiante;
    END LeerMatriculasEstudiante;

    PROCEDURE ActualizarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE,
        p_NuevoSemestre IN Matricula.Semestre%TYPE,
        p_NuevoAnio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        UPDATE Matricula
        SET Semestre = p_NuevoSemestre,
            Anio = p_NuevoAnio
        WHERE CedulaEstudiante = p_CedulaEstudiante
          AND IDMateria = p_IDMateria
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-25003, 'La matrícula no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25004, 'Error al actualizar la matrícula: ' || SQLERRM);
    END ActualizarMatricula;

    PROCEDURE EliminarMatricula(
        p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
        p_IDMateria IN Matricula.IDMateria%TYPE,
        p_Semestre IN Matricula.Semestre%TYPE,
        p_Anio IN Matricula.Anio%TYPE
    ) AS
    BEGIN
        DELETE FROM Matricula
        WHERE CedulaEstudiante = p_CedulaEstudiante
          AND IDMateria = p_IDMateria
          AND Semestre = p_Semestre
          AND Anio = p_Anio;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-25005, 'La matrícula no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-25006, 'Error al eliminar la matrícula: ' || SQLERRM);
    END EliminarMatricula;

END PaqueteMatricula;

CREATE OR REPLACE PACKAGE PaquetePrerrequisitos AS
    -- Procedimiento para crear un prerrequisito
    PROCEDURE CrearPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    );

    -- Procedimiento para leer los prerrequisitos de una materia
    PROCEDURE LeerPrerrequisitosDeMateria(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_Prerrequisitos OUT SYS_REFCURSOR
    );

    -- Procedimiento para eliminar un prerrequisito
    PROCEDURE EliminarPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    );
END PaquetePrerrequisitos;

CREATE OR REPLACE PACKAGE BODY PaquetePrerrequisitos AS

    PROCEDURE CrearPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    ) AS
    BEGIN
        INSERT INTO Prerrequisitos (
            IDMateriaPrincipal, IDMateriaPrerrequisito
        ) VALUES (
            p_IDMateriaPrincipal, p_IDMateriaPrerrequisito
        );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-26001, 'El prerrequisito ya existe.');
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-26002, 'Error al crear el prerrequisito: ' || SQLERRM);
    END CrearPrerrequisito;

    PROCEDURE LeerPrerrequisitosDeMateria(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_Prerrequisitos OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Prerrequisitos FOR
        SELECT * FROM Prerrequisitos
        WHERE IDMateriaPrincipal = p_IDMateriaPrincipal;
    END LeerPrerrequisitosDeMateria;

    PROCEDURE EliminarPrerrequisito(
        p_IDMateriaPrincipal IN Prerrequisitos.IDMateriaPrincipal%TYPE,
        p_IDMateriaPrerrequisito IN Prerrequisitos.IDMateriaPrerrequisito%TYPE
    ) AS
    BEGIN
        DELETE FROM Prerrequisitos
        WHERE IDMateriaPrincipal = p_IDMateriaPrincipal
          AND IDMateriaPrerrequisito = p_IDMateriaPrerrequisito;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-26003, 'El prerrequisito no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-26004, 'Error al eliminar el prerrequisito: ' || SQLERRM);
    END EliminarPrerrequisito;

END PaquetePrerrequisitos;

CREATE OR REPLACE PACKAGE PaqueteCongelamientos AS
    -- Procedimiento para crear un congelamiento
    PROCEDURE CrearCongelamiento(
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    );

    -- Procedimiento para leer un congelamiento
    PROCEDURE LeerCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_Congelamiento OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un congelamiento
    PROCEDURE ActualizarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    );

    -- Procedimiento para eliminar un congelamiento
    PROCEDURE EliminarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE
    );
END PaqueteCongelamientos;

CREATE OR REPLACE PACKAGE BODY PaqueteCongelamientos AS

    PROCEDURE CrearCongelamiento(
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    ) AS
    BEGIN
        INSERT INTO Congelamientos (
            CedulaEstudiante, Motivo, FechaInicio, FechaFin
        ) VALUES (
            p_CedulaEstudiante, p_Motivo, p_FechaInicio, p_FechaFin
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27001, 'Error al crear el congelamiento: ' || SQLERRM);
    END CrearCongelamiento;

    PROCEDURE LeerCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_Congelamiento OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Congelamiento FOR
        SELECT * FROM Congelamientos WHERE ID = p_ID;
    END LeerCongelamiento;

    PROCEDURE ActualizarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE,
        p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
        p_Motivo IN Congelamientos.Motivo%TYPE,
        p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
        p_FechaFin IN Congelamientos.FechaFin%TYPE
    ) AS
    BEGIN
        UPDATE Congelamientos
        SET CedulaEstudiante = p_CedulaEstudiante,
            Motivo = p_Motivo,
            FechaInicio = p_FechaInicio,
            FechaFin = p_FechaFin
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-27002, 'El congelamiento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27003, 'Error al actualizar el congelamiento: ' || SQLERRM);
    END ActualizarCongelamiento;

    PROCEDURE EliminarCongelamiento(
        p_ID IN Congelamientos.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Congelamientos WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-27004, 'El congelamiento con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-27005, 'Error al eliminar el congelamiento: ' || SQLERRM);
    END EliminarCongelamiento;

END PaqueteCongelamientos;

CREATE OR REPLACE PACKAGE PaqueteDireccion AS
    -- Procedimiento para crear una dirección
    PROCEDURE CrearDireccion(
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    );

    -- Procedimiento para leer una dirección
    PROCEDURE LeerDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_Direccion OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar una dirección
    PROCEDURE ActualizarDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    );

    -- Procedimiento para eliminar una dirección
    PROCEDURE EliminarDireccion(
        p_ID IN Direccion.ID%TYPE
    );
END PaqueteDireccion;

CREATE OR REPLACE PACKAGE BODY PaqueteDireccion AS

    PROCEDURE CrearDireccion(
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    ) AS
    BEGIN
        INSERT INTO Direccion (
            CedulaEstudiante, Provincia, Canton, Distrito, DireccionExacta
        ) VALUES (
            p_CedulaEstudiante, p_Provincia, p_Canton, p_Distrito, p_DireccionExacta
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28001, 'Error al crear la dirección: ' || SQLERRM);
    END CrearDireccion;

    PROCEDURE LeerDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_Direccion OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Direccion FOR
        SELECT * FROM Direccion WHERE ID = p_ID;
    END LeerDireccion;

    PROCEDURE ActualizarDireccion(
        p_ID IN Direccion.ID%TYPE,
        p_CedulaEstudiante IN Direccion.CedulaEstudiante%TYPE,
        p_Provincia IN Direccion.Provincia%TYPE,
        p_Canton IN Direccion.Canton%TYPE,
        p_Distrito IN Direccion.Distrito%TYPE,
        p_DireccionExacta IN Direccion.DireccionExacta%TYPE
    ) AS
    BEGIN
        UPDATE Direccion
        SET CedulaEstudiante = p_CedulaEstudiante,
            Provincia = p_Provincia,
            Canton = p_Canton,
            Distrito = p_Distrito,
            DireccionExacta = p_DireccionExacta
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-28002, 'La dirección con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28003, 'Error al actualizar la dirección: ' || SQLERRM);
    END ActualizarDireccion;

    PROCEDURE EliminarDireccion(
        p_ID IN Direccion.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Direccion WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-28004, 'La dirección con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-28005, 'Error al eliminar la dirección: ' || SQLERRM);
    END EliminarDireccion;

END PaqueteDireccion;

CREATE OR REPLACE PACKAGE PaqueteHorarios AS
    -- Procedimiento para crear un horario
    PROCEDURE CrearHorario(
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    );

    -- Procedimiento para leer un horario
    PROCEDURE LeerHorario(
        p_ID IN Horarios.ID%TYPE,
        p_Horario OUT SYS_REFCURSOR
    );

    -- Procedimiento para actualizar un horario
    PROCEDURE ActualizarHorario(
        p_ID IN Horarios.ID%TYPE,
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    );

    -- Procedimiento para eliminar un horario
    PROCEDURE EliminarHorario(
        p_ID IN Horarios.ID%TYPE
    );
END PaqueteHorarios;

CREATE OR REPLACE PACKAGE BODY PaqueteHorarios AS

    PROCEDURE CrearHorario(
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    ) AS
    BEGIN
        INSERT INTO Horarios (
            IDMateria, Aula, HorarioInicio, HorarioFin, DiaSemana
        ) VALUES (
            p_IDMateria, p_Aula, p_HorarioInicio, p_HorarioFin, p_DiaSemana
        );
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29001, 'Error al crear el horario: ' || SQLERRM);
    END CrearHorario;

    PROCEDURE LeerHorario(
        p_ID IN Horarios.ID%TYPE,
        p_Horario OUT SYS_REFCURSOR
    ) AS
    BEGIN
        OPEN p_Horario FOR
        SELECT * FROM Horarios WHERE ID = p_ID;
    END LeerHorario;

    PROCEDURE ActualizarHorario(
        p_ID IN Horarios.ID%TYPE,
        p_IDMateria IN Horarios.IDMateria%TYPE,
        p_Aula IN Horarios.Aula%TYPE,
        p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
        p_HorarioFin IN Horarios.HorarioFin%TYPE,
        p_DiaSemana IN Horarios.DiaSemana%TYPE
    ) AS
    BEGIN
        UPDATE Horarios
        SET IDMateria = p_IDMateria,
            Aula = p_Aula,
            HorarioInicio = p_HorarioInicio,
            HorarioFin = p_HorarioFin,
            DiaSemana = p_DiaSemana
        WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-29002, 'El horario con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29003, 'Error al actualizar el horario: ' || SQLERRM);
    END ActualizarHorario;

    PROCEDURE EliminarHorario(
        p_ID IN Horarios.ID%TYPE
    ) AS
    BEGIN
        DELETE FROM Horarios WHERE ID = p_ID;
        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-29004, 'El horario con ID ' || p_ID || ' no existe.');
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-29005, 'Error al eliminar el horario: ' || SQLERRM);
    END EliminarHorario;

END PaqueteHorarios;

-- Creación del paquete PaqueteUsuarios
CREATE OR REPLACE PACKAGE PaqueteUsuarios AS
    PROCEDURE VerificarCredenciales(
        p_usuario IN Usuarios.Usuario%TYPE,
        p_clave IN Usuarios.Clave%TYPE,
        p_existe OUT CHAR
    );
END PaqueteUsuarios;

-- Creación del cuerpo del paquete PaqueteUsuarios
CREATE OR REPLACE PACKAGE BODY PaqueteUsuarios AS
    PROCEDURE VerificarCredenciales(
        p_usuario IN Usuarios.Usuario%TYPE,
        p_clave IN Usuarios.Clave%TYPE,
        p_existe OUT CHAR
    ) AS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM Usuarios
        WHERE Usuario = p_usuario
          AND Clave = p_clave; -- Compara directamente sin hashing
    
        IF v_count > 0 THEN
            p_existe := '1'; -- Credenciales válidas
        ELSE
            p_existe := '0'; -- Credenciales inválidas
        END IF;
    END VerificarCredenciales;
END PaqueteUsuarios;





--creación de FUNCIONES 
-- Función 1: Total de estudiantes registrados
CREATE OR REPLACE FUNCTION TotalEstudiantesRegistrados RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30001, 'Error al obtener total de estudiantes registrados: ' || SQLERRM);
END TotalEstudiantesRegistrados;
/

-- Función 2: Estudiantes activos
CREATE OR REPLACE FUNCTION TotalEstudiantesActivos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante WHERE Estado = 'activo';
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30002, 'Error al obtener total de estudiantes activos: ' || SQLERRM);
END TotalEstudiantesActivos;
/

-- Función 3: Estudiantes inactivos
CREATE OR REPLACE FUNCTION TotalEstudiantesInactivos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Estudiante WHERE Estado = 'inactivo';
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30003, 'Error al obtener total de estudiantes inactivos: ' || SQLERRM);
END TotalEstudiantesInactivos;
/

-- Función 4: Edad promedio de los estudiantes
CREATE OR REPLACE FUNCTION EdadPromedioEstudiantes RETURN NUMBER IS
    v_EdadPromedio NUMBER;
BEGIN
    SELECT AVG(FLOOR(MONTHS_BETWEEN(SYSDATE, FechaNacimiento) / 12))
    INTO v_EdadPromedio
    FROM Estudiante
    WHERE Estado = 'activo';
    RETURN v_EdadPromedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30004, 'Error al calcular edad promedio de estudiantes: ' || SQLERRM);
END EdadPromedioEstudiantes;
/

-- Función 5: Estudiantes con matrícula activa
CREATE OR REPLACE FUNCTION EstudiantesConMatriculaActiva RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(DISTINCT CedulaEstudiante) INTO v_Total FROM Matricula;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30005, 'Error al obtener estudiantes con matrícula activa: ' || SQLERRM);
END EstudiantesConMatriculaActiva;
/

-- Función 6: Total de profesores registrados
CREATE OR REPLACE FUNCTION TotalProfesoresRegistrados RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Profesor;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30006, 'Error al obtener total de profesores registrados: ' || SQLERRM);
END TotalProfesoresRegistrados;
/

-- Función 7: Materias asignadas
CREATE OR REPLACE FUNCTION TotalMateriasAsignadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Asignacion;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30007, 'Error al obtener total de materias asignadas: ' || SQLERRM);
END TotalMateriasAsignadas;
/

-- Función 8: Promedio de materias por profesor
CREATE OR REPLACE FUNCTION PromedioMateriasPorProfesor RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(MateriasAsignadas) INTO v_Promedio
    FROM (
        SELECT COUNT(*) AS MateriasAsignadas
        FROM Asignacion
        GROUP BY CedulaProfesor
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30008, 'Error al calcular promedio de materias por profesor: ' || SQLERRM);
END PromedioMateriasPorProfesor;
/

-- Función 9: Profesores con titulaciones avanzadas
CREATE OR REPLACE FUNCTION ProfesoresConTitulacionesAvanzadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM Profesor
    WHERE LOWER(TituloAcademico) IN ('maestría', 'maestria', 'doctorado');
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30009, 'Error al obtener profesores con titulaciones avanzadas: ' || SQLERRM);
END ProfesoresConTitulacionesAvanzadas;
/

-- Función 10: Carga horaria promedio por profesor
CREATE OR REPLACE FUNCTION CargaHorariaPromedioPorProfesor RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(TotalHoras) INTO v_Promedio
    FROM (
        SELECT P.Cedula, SUM(
            EXTRACT(HOUR FROM (H.HorarioFin - H.HorarioInicio)) +
            EXTRACT(MINUTE FROM (H.HorarioFin - H.HorarioInicio)) / 60
        ) AS TotalHoras
        FROM Horarios H
        INNER JOIN Asignacion A ON H.IDMateria = A.IDMateria
        INNER JOIN Profesor P ON A.CedulaProfesor = P.Cedula
        GROUP BY P.Cedula
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30010, 'Error al calcular carga horaria promedio por profesor: ' || SQLERRM);
END CargaHorariaPromedioPorProfesor;
/

-- Función 11: Total de materias ofertadas
CREATE OR REPLACE FUNCTION TotalMateriasOfertadas RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total FROM Materia;
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30011, 'Error al obtener total de materias ofertadas: ' || SQLERRM);
END TotalMateriasOfertadas;
/

-- Función 12: Materias sin prerrequisitos
CREATE OR REPLACE FUNCTION TotalMateriasSinPrerrequisitos RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM Materia M
    WHERE NOT EXISTS (
        SELECT 1 FROM Prerrequisitos PR WHERE PR.IDMateriaPrincipal = M.ID
    );
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30012, 'Error al obtener total de materias sin prerrequisitos: ' || SQLERRM);
END TotalMateriasSinPrerrequisitos;
/

-- Función 13: Materias con cupo disponible
CREATE OR REPLACE FUNCTION TotalMateriasConCupoDisponible(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER,
    p_CupoMaximo IN NUMBER DEFAULT 30
) RETURN NUMBER IS
    v_Total NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_Total
    FROM (
        SELECT M.ID, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID
        HAVING COUNT(DISTINCT MT.CedulaEstudiante) < p_CupoMaximo
    );
    RETURN v_Total;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30013, 'Error al obtener materias con cupo disponible: ' || SQLERRM);
END TotalMateriasConCupoDisponible;
/

-- Función 14: Promedio de estudiantes por materia
CREATE OR REPLACE FUNCTION PromedioEstudiantesPorMateria(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER
) RETURN NUMBER IS
    v_Promedio NUMBER;
BEGIN
    SELECT AVG(NumEstudiantes) INTO v_Promedio
    FROM (
        SELECT M.ID, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID
    );
    RETURN v_Promedio;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-30014, 'Error al calcular promedio de estudiantes por materia: ' || SQLERRM);
END PromedioEstudiantesPorMateria;
/

-- Función 15: Materias más demandadas
CREATE OR REPLACE FUNCTION MateriasMasDemandadas(
    p_Semestre IN NUMBER,
    p_Anio IN NUMBER,
    p_TopN IN NUMBER
) RETURN SYS_REFCURSOR IS
    v_Materias SYS_REFCURSOR;
BEGIN
    OPEN v_Materias FOR
    SELECT *
    FROM (
        SELECT M.ID, M.Nombre, COUNT(DISTINCT MT.CedulaEstudiante) AS NumEstudiantes
        FROM Materia M
        LEFT JOIN Matricula MT ON M.ID = MT.IDMateria
            AND MT.Semestre = p_Semestre
            AND MT.Anio = p_Anio
        GROUP BY M.ID, M.Nombre
        ORDER BY NumEstudiantes DESC
    )
    WHERE ROWNUM <= p_TopN;
    RETURN v_Materias;
END MateriasMasDemandadas;

-- Procedimiento para obtener el total de estudiantes registrados
CREATE OR REPLACE PROCEDURE ObtenerTotalEstudiantesRegistrados(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalEstudiantesRegistrados();
END ObtenerTotalEstudiantesRegistrados;
/

-- Procedimiento para obtener el total de estudiantes activos
CREATE OR REPLACE PROCEDURE ObtenerTotalEstudiantesActivos(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalEstudiantesActivos();
END ObtenerTotalEstudiantesActivos;
/

-- Procedimiento para obtener el total de estudiantes inactivos
CREATE OR REPLACE PROCEDURE ObtenerTotalEstudiantesInactivos(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalEstudiantesInactivos();
END ObtenerTotalEstudiantesInactivos;
/

-- Procedimiento para obtener la edad promedio de estudiantes
CREATE OR REPLACE PROCEDURE ObtenerEdadPromedioEstudiantes(p_promedio OUT NUMBER) AS
BEGIN
    p_promedio := EdadPromedioEstudiantes();
END ObtenerEdadPromedioEstudiantes;
/

-- Procedimiento para obtener estudiantes con matrícula activa
CREATE OR REPLACE PROCEDURE ObtenerEstudiantesConMatriculaActiva(p_total OUT NUMBER) AS
BEGIN
    p_total := EstudiantesConMatriculaActiva();
END ObtenerEstudiantesConMatriculaActiva;
/

-- Procedimiento para obtener el total de profesores registrados
CREATE OR REPLACE PROCEDURE ObtenerTotalProfesoresRegistrados(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalProfesoresRegistrados();
END ObtenerTotalProfesoresRegistrados;
/

-- Procedimiento para obtener el total de materias asignadas
CREATE OR REPLACE PROCEDURE ObtenerTotalMateriasAsignadas(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalMateriasAsignadas();
END ObtenerTotalMateriasAsignadas;
/

-- Procedimiento para obtener el promedio de materias por profesor
CREATE OR REPLACE PROCEDURE ObtenerPromedioMateriasPorProfesor(p_promedio OUT NUMBER) AS
BEGIN
    p_promedio := PromedioMateriasPorProfesor();
END ObtenerPromedioMateriasPorProfesor;
/

-- Procedimiento para obtener profesores con titulaciones avanzadas
CREATE OR REPLACE PROCEDURE ObtenerProfesoresConTitulacionesAvanzadas(p_total OUT NUMBER) AS
BEGIN
    p_total := ProfesoresConTitulacionesAvanzadas();
END ObtenerProfesoresConTitulacionesAvanzadas;
/

-- Procedimiento para obtener la carga horaria promedio por profesor
CREATE OR REPLACE PROCEDURE ObtenerCargaHorariaPromedioPorProfesor(p_promedio OUT NUMBER) AS
BEGIN
    p_promedio := CargaHorariaPromedioPorProfesor();
END ObtenerCargaHorariaPromedioPorProfesor;
/

-- Procedimiento para obtener el total de materias ofertadas
CREATE OR REPLACE PROCEDURE ObtenerTotalMateriasOfertadas(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalMateriasOfertadas();
END ObtenerTotalMateriasOfertadas;
/

-- Procedimiento para obtener el total de materias sin prerrequisitos
CREATE OR REPLACE PROCEDURE ObtenerTotalMateriasSinPrerrequisitos(p_total OUT NUMBER) AS
BEGIN
    p_total := TotalMateriasSinPrerrequisitos();
END ObtenerTotalMateriasSinPrerrequisitos;
/

-- Procedimiento para obtener el total de materias con cupo disponible
CREATE OR REPLACE PROCEDURE ObtenerTotalMateriasConCupoDisponible(
    p_semestre IN NUMBER,
    p_anio IN NUMBER,
    p_total OUT NUMBER
) AS
BEGIN
    p_total := TotalMateriasConCupoDisponible(p_semestre, p_anio);
END ObtenerTotalMateriasConCupoDisponible;
/

-- Procedimiento para obtener el promedio de estudiantes por materia
CREATE OR REPLACE PROCEDURE ObtenerPromedioEstudiantesPorMateria(
    p_semestre IN NUMBER,
    p_anio IN NUMBER,
    p_promedio OUT NUMBER
) AS
BEGIN
    p_promedio := PromedioEstudiantesPorMateria(p_semestre, p_anio);
END ObtenerPromedioEstudiantesPorMateria;
/

-- Procedimiento para obtener las materias más demandadas
CREATE OR REPLACE PROCEDURE ObtenerMateriasMasDemandadas(
    p_semestre IN NUMBER,
    p_anio IN NUMBER,
    p_topn IN NUMBER,
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    p_cursor := MateriasMasDemandadas(p_semestre, p_anio, p_topn);
END ObtenerMateriasMasDemandadas;
/
/* 
Módulo Estudiantes
Vista 1: registro_estudiantes
Vista 2: consultar_editar_estudiantes
Vista 3: historial_academico_estudiantes

*/


--Vista 2: VistaConsultarEditarEstudiantes

CREATE OR REPLACE VIEW ConsultarEditarEstudiantes AS
SELECT 
    Cedula,
    Nombre,
    CorreoElectronico AS Correo,
    Telefono,
    Estado
FROM Estudiante;

CREATE OR REPLACE PROCEDURE ConsultarEstudiantes(
    p_cursor OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_cursor FOR
    SELECT 
        Cedula,
        Nombre,
        CorreoElectronico AS Correo,
        Telefono,
        Estado
    FROM Estudiante;
END ConsultarEstudiantes;

CREATE OR REPLACE PROCEDURE ActualizarEstudiante(
    p_cedula IN Estudiante.Cedula%TYPE,
    p_nombre IN Estudiante.Nombre%TYPE,
    p_correo IN Estudiante.CorreoElectronico%TYPE,
    p_telefono IN Estudiante.Telefono%TYPE,
    p_estado IN Estudiante.Estado%TYPE
) AS
BEGIN
    UPDATE Estudiante
    SET 
        Nombre = p_nombre,
        CorreoElectronico = p_correo,
        Telefono = p_telefono,
        Estado = p_estado
    WHERE Cedula = p_cedula;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'Estudiante no encontrado para actualizar.');
    END IF;
END ActualizarEstudiante;


--Vista 3: HistorialAcademico

CREATE OR REPLACE VIEW VistaHistorialAcademico AS
SELECT
    E.Cedula AS CedulaEstudiante,
    E.Nombre || ' ' || E.Apellidos AS NombreEstudiante,
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    MT.Semestre,
    MT.Anio,
    MT.FechaMatricula,
    C.Calificacion
FROM Matricula MT
INNER JOIN Estudiante E ON MT.CedulaEstudiante = E.Cedula
INNER JOIN Materia M ON MT.IDMateria = M.ID
LEFT JOIN Calificaciones C ON MT.CedulaEstudiante = C.CedulaEstudiante AND MT.IDMateria = C.IDMateria;

/*Módulo Profesores
Vista 1: registro_profesores
Vista 2: asignaciones_profesor
Vista 3: consultar_editar_profesores
*/

--Vista : registro_profesores

-- Creación del procedimiento para registrar un profesor
CREATE OR REPLACE PROCEDURE RegistrarProfesor(
    p_Cedula IN Profesor.Cedula%TYPE,
    p_IDDepartamento IN Profesor.IDDepartamento%TYPE,
    p_Nombre IN Profesor.Nombre%TYPE,
    p_Apellidos IN Profesor.Apellidos%TYPE,
    p_Telefono IN Profesor.Telefono%TYPE,
    p_CorreoElectronico IN Profesor.CorreoElectronico%TYPE,
    p_TituloAcademico IN Profesor.TituloAcademico%TYPE
) AS
BEGIN
    INSERT INTO Profesor (
        Cedula, IDDepartamento, Nombre, Apellidos, Telefono, CorreoElectronico, FechaInscripcion, TituloAcademico
    ) VALUES (
        p_Cedula, p_IDDepartamento, p_Nombre, p_Apellidos, p_Telefono, p_CorreoElectronico, SYSDATE, p_TituloAcademico
    );
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        RAISE_APPLICATION_ERROR(-20001, 'El profesor con esta cédula ya existe.');
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Error al registrar el profesor: ' || SQLERRM);
END RegistrarProfesor;
/

--vista registrar profesor 

-- SQL: Crear el procedimiento para registrar asignaciones de profesor
CREATE OR REPLACE PROCEDURE RegistrarAsignacionProfesor(
    p_CedulaProfesor IN Profesor.Cedula%TYPE,
    p_IDMateria IN Materia.ID%TYPE,
    p_Semestre IN Asignacion.Semestre%TYPE,
    p_Anio IN Asignacion.Anio%TYPE
) AS
BEGIN
    INSERT INTO Asignacion (
        CedulaProfesor, IDMateria, Semestre, Anio
    ) VALUES (
        p_CedulaProfesor, p_IDMateria, p_Semestre, p_Anio
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al registrar asignación: ' || SQLERRM);
END RegistrarAsignacionProfesor;
/

-- SQL: Crear la vista para las asignaciones de profesores
CREATE OR REPLACE VIEW VistaAsignacionesProfesor AS
SELECT
    P.Cedula AS CedulaProfesor,
    P.Nombre || ' ' || P.Apellidos AS NombreProfesor,
    M.ID AS IDMateria,
    M.Nombre AS NombreMateria,
    A.Semestre,
    A.Anio
FROM Asignacion A
INNER JOIN Profesor P ON A.CedulaProfesor = P.Cedula
INNER JOIN Materia M ON A.IDMateria = M.ID;
/

CREATE OR REPLACE PROCEDURE ObtenerProfesoresCursor(p_cursor OUT SYS_REFCURSOR) AS
BEGIN
    OPEN p_cursor FOR
    SELECT Cedula, IDDepartamento, Nombre, Apellidos, Telefono, CorreoElectronico, TituloAcademico
    FROM Profesor;
END ObtenerProfesoresCursor;
/

--vista asignacion profesor 

CREATE OR REPLACE VIEW VistaAsignacionesProfesores AS
SELECT
    P.Nombre || ' ' || P.Apellidos AS NombreProfesor,
    M.Nombre AS NombreMateria,
    A.Semestre,
    A.Anio,
    A.IDMateria,
    A.CedulaProfesor
FROM Asignacion A
INNER JOIN Profesor P ON A.CedulaProfesor = P.Cedula
INNER JOIN Materia M ON A.IDMateria = M.ID;

CREATE OR REPLACE PROCEDURE ObtenerAsignacionesProfesores (
    p_resultado OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_resultado FOR
    SELECT * FROM VistaAsignacionesProfesores;
END;

--vista consultar editar profesores 
CREATE OR REPLACE PROCEDURE ObtenerProfesor(
    p_cedula IN Profesor.Cedula%TYPE,
    p_result OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_result FOR
    SELECT Cedula, IDDepartamento, Nombre, Apellidos, Telefono, CorreoElectronico, TituloAcademico
    FROM Profesor
    WHERE Cedula = p_cedula;
END ObtenerProfesor;

CREATE OR REPLACE PROCEDURE ActualizarProfesor(
    p_cedula IN Profesor.Cedula%TYPE,
    p_id_departamento IN Profesor.IDDepartamento%TYPE,
    p_nombre IN Profesor.Nombre%TYPE,
    p_apellidos IN Profesor.Apellidos%TYPE,
    p_telefono IN Profesor.Telefono%TYPE,
    p_correo IN Profesor.CorreoElectronico%TYPE,
    p_titulo IN Profesor.TituloAcademico%TYPE
) AS
BEGIN
    UPDATE Profesor
    SET
        IDDepartamento = p_id_departamento,
        Nombre = p_nombre,
        Apellidos = p_apellidos,
        Telefono = p_telefono,
        CorreoElectronico = p_correo,
        TituloAcademico = p_titulo
    WHERE Cedula = p_cedula;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'No se encontró un profesor con la cédula especificada.');
    END IF;
END ActualizarProfesor;
/

/


/*Módulo Materias
Vista 1: registro_materias
Vista 2: plan_estudios
Vista 3: prerrequisitos_materias*/

--Vista 1: registro_materias
CREATE OR REPLACE PROCEDURE RegistrarMateria(
    p_nombre IN Materia.Nombre%TYPE,
    p_descripcion IN Materia.Descripcion%TYPE,
    p_creditos IN Materia.Creditos%TYPE
) AS
BEGIN
    INSERT INTO Materia (Nombre, Descripcion, Creditos)
    VALUES (p_nombre, p_descripcion, p_creditos);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al registrar la materia: ' || SQLERRM);
END RegistrarMateria;
/

--vista plan estudios 
CREATE OR REPLACE VIEW VistaPlanEstudios AS
SELECT
    ID AS Codigo,
    Nombre AS NombreMateria,
    Descripcion,
    Creditos
FROM Materia;

--prerrequisitos materias 
CREATE OR REPLACE VIEW VistaPrerrequisitosMaterias AS
SELECT 
    MP.ID AS IDMateriaPrincipal,
    MP.Nombre AS NombreMateriaPrincipal,
    MPR.ID AS IDMateriaPrerrequisito,
    MPR.Nombre AS NombreMateriaPrerrequisito
FROM Prerrequisitos PR
INNER JOIN Materia MP ON PR.IDMateriaPrincipal = MP.ID
INNER JOIN Materia MPR ON PR.IDMateriaPrerrequisito = MPR.ID;


/*
Módulo Horarios
Vista 1: registro_horarios
Vista 2: consultar_horarios
Vista 3: aulas_asignadas*/


-- Procedimiento para registrar horarios
CREATE OR REPLACE PROCEDURE RegistrarHorario(
    p_IDMateria IN Horarios.IDMateria%TYPE,
    p_Aula IN Horarios.Aula%TYPE,
    p_HorarioInicio IN Horarios.HorarioInicio%TYPE,
    p_HorarioFin IN Horarios.HorarioFin%TYPE,
    p_DiaSemana IN Horarios.DiaSemana%TYPE
) AS
BEGIN
    INSERT INTO Horarios (
        IDMateria, Aula, HorarioInicio, HorarioFin, DiaSemana
    ) VALUES (
        p_IDMateria, p_Aula, p_HorarioInicio, p_HorarioFin, p_DiaSemana
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al registrar el horario: ' || SQLERRM);
END RegistrarHorario;
/

-- Cursor para consultar horarios
CREATE OR REPLACE FUNCTION ConsultarHorarios RETURN SYS_REFCURSOR IS
    v_Horarios SYS_REFCURSOR;
BEGIN
    OPEN v_Horarios FOR
    SELECT H.ID, M.Nombre AS Materia, H.Aula, H.HorarioInicio, H.HorarioFin, H.DiaSemana
    FROM Horarios H
    JOIN Materia M ON H.IDMateria = M.ID;
    RETURN v_Horarios;
END ConsultarHorarios;
/
-- Cursor para consultar aulas asignadas
CREATE OR REPLACE FUNCTION AulasAsignadas RETURN SYS_REFCURSOR IS
    v_Aulas SYS_REFCURSOR;
BEGIN
    OPEN v_Aulas FOR
    SELECT DISTINCT H.Aula, H.DiaSemana, M.Nombre AS Materia, P.Nombre AS Profesor
    FROM Horarios H
    JOIN Materia M ON H.IDMateria = M.ID
    JOIN Asignacion A ON M.ID = A.IDMateria
    JOIN Profesor P ON A.CedulaProfesor = P.Cedula;
    RETURN v_Aulas;
END AulasAsignadas;
/


/*
Módulo Matrículas
Vista 1: registro_matriculas
Vista 2: consultar_editar_matriculas
Vista 3: reporte_matriculas*/

-- Procedimiento para registrar una matrícula
CREATE OR REPLACE PROCEDURE RegistrarMatricula(
    p_CedulaEstudiante IN Matricula.CedulaEstudiante%TYPE,
    p_IDMateria IN Matricula.IDMateria%TYPE,
    p_Semestre IN Matricula.Semestre%TYPE,
    p_Anio IN Matricula.Anio%TYPE
) AS
BEGIN
    INSERT INTO Matricula (
        CedulaEstudiante, IDMateria, Semestre, Anio, FechaMatricula
    ) VALUES (
        p_CedulaEstudiante, p_IDMateria, p_Semestre, p_Anio, SYSDATE
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al registrar la matrícula: ' || SQLERRM);
END RegistrarMatricula;
/
-- Cursor para consultar todas las matrículas
CREATE OR REPLACE FUNCTION ConsultarMatriculas RETURN SYS_REFCURSOR IS
    v_Matriculas SYS_REFCURSOR;
BEGIN
    OPEN v_Matriculas FOR
    SELECT MT.CedulaEstudiante, E.Nombre || ' ' || E.Apellidos AS Estudiante, M.Nombre AS Materia, MT.Semestre, MT.Anio, MT.FechaMatricula
    FROM Matricula MT
    JOIN Estudiante E ON MT.CedulaEstudiante = E.Cedula
    JOIN Materia M ON MT.IDMateria = M.ID;
    RETURN v_Matriculas;
END ConsultarMatriculas;
/
-- Cursor para generar un reporte de matrículas agrupadas por materias
CREATE OR REPLACE FUNCTION ReporteMatriculas RETURN SYS_REFCURSOR IS
    v_Reporte SYS_REFCURSOR;
BEGIN
    OPEN v_Reporte FOR
    SELECT M.Nombre AS Materia, COUNT(MT.CedulaEstudiante) AS Estudiantes, MT.Semestre, MT.Anio
    FROM Matricula MT
    JOIN Materia M ON MT.IDMateria = M.ID
    GROUP BY M.Nombre, MT.Semestre, MT.Anio
    ORDER BY MT.Anio DESC, MT.Semestre;
    RETURN v_Reporte;
END ReporteMatriculas;
/



/*
Módulo Congelamientos
Vista 1: registro_congelamientos
Vista 2: consultar_congelamientos
Vista 3: congelamientos_activos*/

-- Procedimiento para registrar un congelamiento
CREATE OR REPLACE PROCEDURE RegistrarCongelamiento(
    p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE,
    p_Motivo IN Congelamientos.Motivo%TYPE,
    p_FechaInicio IN Congelamientos.FechaInicio%TYPE,
    p_FechaFin IN Congelamientos.FechaFin%TYPE
) AS
BEGIN
    INSERT INTO Congelamientos (
        CedulaEstudiante, Motivo, FechaInicio, FechaFin
    ) VALUES (
        p_CedulaEstudiante, p_Motivo, p_FechaInicio, p_FechaFin
    );
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'Error al registrar el congelamiento: ' || SQLERRM);
END RegistrarCongelamiento;
/
-- Cursor para consultar congelamientos de un estudiante
CREATE OR REPLACE FUNCTION ConsultarCongelamientos(
    p_CedulaEstudiante IN Congelamientos.CedulaEstudiante%TYPE
) RETURN SYS_REFCURSOR IS
    v_Congelamientos SYS_REFCURSOR;
BEGIN
    OPEN v_Congelamientos FOR
    SELECT C.ID, C.Motivo, TO_CHAR(C.FechaInicio, 'YYYY-MM-DD') AS FechaInicio, TO_CHAR(C.FechaFin, 'YYYY-MM-DD') AS FechaFin
    FROM Congelamientos C
    WHERE C.CedulaEstudiante = p_CedulaEstudiante;
    RETURN v_Congelamientos;
END ConsultarCongelamientos;
/
-- Cursor para consultar congelamientos activos
CREATE OR REPLACE FUNCTION CongelamientosActivos RETURN SYS_REFCURSOR IS
    v_Activos SYS_REFCURSOR;
BEGIN
    OPEN v_Activos FOR
    SELECT C.ID, E.Cedula, E.Nombre || ' ' || E.Apellidos AS Estudiante, C.Motivo, TO_CHAR(C.FechaInicio, 'YYYY-MM-DD') AS FechaInicio
    FROM Congelamientos C
    JOIN Estudiante E ON C.CedulaEstudiante = E.Cedula
    WHERE C.FechaFin IS NULL;
    RETURN v_Activos;
END CongelamientosActivos;
/


--Creacion de Triggers 
--Trigger 1: Actualizar Estado del Estudiante al Registrar un Congelamiento
CREATE OR REPLACE TRIGGER trg_EstadoEstudiante_Congelamiento
AFTER INSERT ON Congelamientos
FOR EACH ROW
BEGIN
    UPDATE Estudiante
    SET Estado = 'inactivo'
    WHERE Cedula = :NEW.CedulaEstudiante;
END;

--Trigger 2: Validar Prerrequisitos al Matricular una Materia
CREATE OR REPLACE TRIGGER trg_ValidarPrerrequisitos_Matricula
BEFORE INSERT ON Matricula
FOR EACH ROW
DECLARE
    v_Count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_Count
    FROM Prerrequisitos PR
    WHERE PR.IDMateriaPrincipal = :NEW.IDMateria
    AND NOT EXISTS (
        SELECT 1
        FROM Matricula MT
        WHERE MT.CedulaEstudiante = :NEW.CedulaEstudiante
        AND MT.IDMateria = PR.IDMateriaPrerrequisito
    );

    IF v_Count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'El estudiante no cumple con los prerrequisitos para esta materia.');
    END IF;
END;

--Trigger 3: Prevenir Solapamiento de Horarios en el Mismo Aula
CREATE OR REPLACE TRIGGER trg_PrevenirSolapamiento_Horarios
BEFORE INSERT OR UPDATE ON Horarios
FOR EACH ROW
DECLARE
    v_Count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_Count
    FROM Horarios H
    WHERE H.Aula = :NEW.Aula
    AND H.DiaSemana = :NEW.DiaSemana
    AND H.ID <> NVL(:OLD.ID, 0)
    AND (
        (:NEW.HorarioInicio BETWEEN H.HorarioInicio AND H.HorarioFin)
        OR
        (:NEW.HorarioFin BETWEEN H.HorarioInicio AND H.HorarioFin)
        OR
        (H.HorarioInicio BETWEEN :NEW.HorarioInicio AND :NEW.HorarioFin)
    );

    IF v_Count > 0 THEN
        RAISE_APPLICATION_ERROR(-20002, 'Existe un horario que se solapa en el mismo aula y día.');
    END IF;
END;

--Trigger 4: Registrar Historial de Cambios en la Tabla Matricula
-- Creación de la tabla de auditoría
CREATE TABLE Matricula_Historial (
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CedulaEstudiante VARCHAR2(50),
    IDMateria NUMBER,
    Semestre NUMBER,
    Anio NUMBER,
    Operacion VARCHAR2(10),
    Usuario VARCHAR2(50),
    FechaOperacion DATE
);
/

-- Trigger para registrar el historial
CREATE OR REPLACE TRIGGER trg_Auditoria_Matricula
AFTER INSERT OR UPDATE OR DELETE ON Matricula
FOR EACH ROW
BEGIN
    INSERT INTO Matricula_Historial (
        CedulaEstudiante, IDMateria, Semestre, Anio, Operacion, Usuario, FechaOperacion
    ) VALUES (
        COALESCE(:NEW.CedulaEstudiante, :OLD.CedulaEstudiante),
        COALESCE(:NEW.IDMateria, :OLD.IDMateria),
        COALESCE(:NEW.Semestre, :OLD.Semestre),
        COALESCE(:NEW.Anio, :OLD.Anio),
        CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING THEN 'UPDATE'
            WHEN DELETING THEN 'DELETE'
        END,
        USER,
        SYSDATE
    );
END;

--Trigger 5: Actualizar Fecha de Fin de Congelamiento al Reactivar Estudiante
CREATE OR REPLACE TRIGGER trg_ActualizarCongelamiento_Estudiante
AFTER UPDATE OF Estado ON Estudiante
FOR EACH ROW
BEGIN
    IF :OLD.Estado = 'inactivo' AND :NEW.Estado = 'activo' THEN
        UPDATE Congelamientos
        SET FechaFin = SYSDATE
        WHERE CedulaEstudiante = :NEW.Cedula
        AND FechaFin IS NULL;
    END IF;
END;

--Creacion de CURSORES
--Cursor 1: Listar Materias sin Prerrequisitos
CREATE OR REPLACE FUNCTION ListarMateriasSinPrerrequisitos RETURN SYS_REFCURSOR IS
    v_Materias SYS_REFCURSOR;
BEGIN
    OPEN v_Materias FOR
    SELECT M.ID, M.Nombre, M.Creditos
    FROM Materia M
    WHERE NOT EXISTS (
        SELECT 1
        FROM Prerrequisitos PR
        WHERE PR.IDMateriaPrincipal = M.ID
    );
    
    RETURN v_Materias;
END ListarMateriasSinPrerrequisitos;


--Cursor 2: Listar Estudiantes con Congelamientos Activos
CREATE OR REPLACE PROCEDURE ListarEstudiantesCongelados(
    p_Estudiantes OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_Estudiantes FOR
    SELECT E.Cedula, E.Nombre, E.Apellidos, C.FechaInicio
    FROM Estudiante E
    INNER JOIN Congelamientos C ON E.Cedula = C.CedulaEstudiante
    WHERE C.FechaFin IS NULL;
END ListarEstudiantesCongelados;

--Cursor 3: Listar Profesores y sus Materias Asignadas
CREATE OR REPLACE FUNCTION ListarProfesoresConMaterias RETURN SYS_REFCURSOR IS
    v_ProfesoresMaterias SYS_REFCURSOR;
BEGIN
    OPEN v_ProfesoresMaterias FOR
    SELECT P.Cedula, P.Nombre || ' ' || P.Apellidos AS NombreProfesor, M.ID AS IDMateria, M.Nombre AS NombreMateria
    FROM Profesor P
    INNER JOIN Asignacion A ON P.Cedula = A.CedulaProfesor
    INNER JOIN Materia M ON A.IDMateria = M.ID;
    
    RETURN v_ProfesoresMaterias;
END ListarProfesoresConMaterias;

--Cursor 4: Listar Direcciones por Provincia
CREATE OR REPLACE PROCEDURE ListarDireccionesPorProvincia(
    p_Provincia IN Direccion.Provincia%TYPE,
    p_Direcciones OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN p_Direcciones FOR
    SELECT D.CedulaEstudiante, E.Nombre || ' ' || E.Apellidos AS NombreEstudiante, D.Canton, D.Distrito, D.DireccionExacta
    FROM Direccion D
    INNER JOIN Estudiante E ON D.CedulaEstudiante = E.Cedula
    WHERE D.Provincia = p_Provincia;
END ListarDireccionesPorProvincia;


--Cursor 5: Obtener Historial de Matriculas de un Estudiante
CREATE OR REPLACE FUNCTION ObtenerHistorialMatriculas(
    p_CedulaEstudiante IN Estudiante.Cedula%TYPE
) RETURN SYS_REFCURSOR IS
    v_Historial SYS_REFCURSOR;
BEGIN
    OPEN v_Historial FOR
    SELECT M.ID AS IDMateria, M.Nombre AS NombreMateria, MT.Semestre, MT.Anio, MT.FechaMatricula
    FROM Matricula MT
    INNER JOIN Materia M ON MT.IDMateria = M.ID
    WHERE MT.CedulaEstudiante = p_CedulaEstudiante
    ORDER BY MT.Anio DESC, MT.Semestre DESC;
    
    RETURN v_Historial;
END ObtenerHistorialMatriculas;

/*
Estructuras Avanzadas:

25 procedimientos almacenados.                   implementados 40
15 funciones adicionales.                        implementados 15
10 vistas optimizadas.                           implementados 10
10 paquetes organizadores.                       implementados 10
5 triggers específicos.                          implementados 5
15 cursores para manejo de datos complejos.      implementados 19
*/